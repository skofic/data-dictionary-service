{
  "info": {
    "name": "Dictionary API Document.paw",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
  },
  "item": [
    {
      "name": "TERMS",
      "item": [
        {
          "name": "Create term",
          "request": {
            "method": "POST",
            "url": {
              "raw": "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/terms/insert?terms=true&types=false&defns=false&resolve=true&resfld=_lid&save=true",
              "query": [
                {
                  "key": "terms",
                  "value": "true",
                  "disabled": false,
                  "description": "Expect all object properties to be part of the data dictionary.\nBy default, if a property matches a descriptor, then the value must conform to the descriptor's data definition; if the property does not match a term in the data dictionary, then it will be ignored and assumed correct. If you set this flag, all object properties must correspond to a descriptor, failing to do so will be considered an error."
                },
                {
                  "key": "types",
                  "value": "false",
                  "disabled": false,
                  "description": "Expect all scalar data sections to have the data type.\nBy default, if a scalar data definition section is empty, we assume the value can take any scalar value: if you set this flag, it means that all scalar data definition sections need to indicate the data type, failing to do so will be considered an error."
                },
                {
                  "key": "defns",
                  "value": "false",
                  "disabled": false,
                  "description": "Allow referencing default namespace.\nThe default namespace is reserved to terms that constitute the dictionary engine. User-defined terms should not reference the default namespace. If this option is set, it will be possible to create terms that have the default namespace as their namespace."
                },
                {
                  "key": "resolve",
                  "value": "true",
                  "disabled": false,
                  "description": "Attempt to resolve unmatched term references.\nThis option is relevant to enumerated values. If this flag is set, when a provided value does not resolve into a term global identifier, the value will be tested against the terms code section property indicated in the resfld parameter: if there is a single match, the original value will be replaced by the matched global identifier. This way one can use the local identifier as the reference and let the validator resolve the global identifier.\nWhen this happens the status code will be zero, if no errors have occurred, but the response will feature a property named changes in the status report, which contains the list of resolved values.\nBe aware that to successfully use this feature the local identifiers must be unique."
                },
                {
                  "key": "resfld",
                  "value": "_lid",
                  "disabled": false,
                  "description": "Terms code section field used to resolve term references.\nThis option is relevant if the resolve flag was set. This parameter corresponds to the name of a property in the descriptor's code section: the unresolved value will be matched against the value contained in that field and if there is a single match, the matched term global identifier will replace the provided value.\nBy default this parameter is set to the local identifier, you could set it, for instance, to the list of official identifiers in order to have a larger choice."
                },
                {
                  "key": "save",
                  "value": "true",
                  "disabled": false,
                  "description": "Flag to determine whether to save the term or not.\nThis option can be used when inserting or updating terms: if the flag is set, if all the required validations tests pass, the term will be either inserted or updated. If the flag is not set, you will get the status of the validation provess. This flag is useful if you just need to check if the term is valid, or if you want to see if the updated term structure before persisting the object to the data dictionary."
                }
              ],
              "protocol": null,
              "host": [
                "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/terms/insert"
              ],
              "port": null,
              "path": null
            },
            "description": "Use this service to create a new term.\n\n*In order to create a term, the current user must have the `dict` role*.\n\nThis service can be used to create a new term, or to check if the provided term would be accepted.\n\nThe service expects the term object in the body. It is required to have at least the `_code` and `_info` data blocks. The `_code` block is required to have at least the `_lid`. The global identifier will be set, and overwritten, by the service. The list of official identifiers will also be set if missing.\n\nThe `_info` block requires the `_title` property. Remember that all elements, except `_provider`, are dictionaries with the *language code* as the dictionary key and the text as the dictionary value: you will have to provide by default the *entry* in the *default language* (`language` *entry in the service settings*).\n\nThe `_data` section and the `_rule` section should be included depending on what type of term you are creating.\n\nThe document key will be automatically set and overwritten with the value of the global identifier.\n\nThere are a number of option parameters that govern the service, these are described in the URL parameters section.\n\nIf the service is successful [`200`] it will return a value depending whether the `save` parameter was *set* or not:\n\n- `save` was *set*: The service will return the inserted term including the `_id` and the `_rev` properties.\n- `save` was *not set*: The service will return an object structured as follows:\n    - `status`: The status of the operation: `0` for success.\n    - `value`: The provided term with the global identifier and document key set.\n\nIf the `resolve` parameter was *set* and at least one value in the provided term was updated, the service will return an HTTP status of [`202`] and object with the following properties:\n\n- `status`: The validation status which is one.\n- `report`: The status report comprised of the following elements:\n    - `status`: The status report:\n      - `status`: The status code, that will be zero.\n      - `message`: The status message.\n    - `changes`: An object containing the list of resolved fields.\n- `value`: The provided term with the resolved fields, and the document `_id` and `_rev` properties if the `save` parameter was *set*.\n\nIf the validation failed, the service will return a [`400`] status and an object with the following properties:\n\n- `status`: The validation status which is minus one.\n- `report`: The status report comprised of the following elements:\n    - `status`: The status report:\n      - `status`: The status code.\n      - `message`: The status message describing the error.\n    - `descriptor`: The name of the property that contains the error.\n    - `value`: The value of the incorrect property\n- `value`: The provided term.\n\nOther status codes are the following:\n\n- `401`: **No current user**: the service will return this code if no user is currently logged in.\n- `403`: **Unauthorised user**: the service will return this code if the current user is not an administrator.\n- `409`: **Term exists**: the service will return this code if the provided term already exists.\n- `500`: For other types of error.\n",
            "header": [],
            "body": {
              "mode": "raw",
              "disabled": false,
              "raw": "{\n  \"_code\": {\n    \"_lid\": \"test\"\n  },\n  \"_info\": {\n    \"_title\": {\n      \"eng\": \"Test term\"\n    },\n    \"_definition\": {\n      \"eng\": \"A term created for testing purposes.\"\n    },\n    \"_description\": {\n      \"eng\": \"This term can be *safely deleted*.\"\n    }\n  },\n  \"_data\": {\n    \"_scalar\": {\n      \"_type\": \"enum\",\n      \"_kind\": [\"_type\"]\n    }\n  }\n}"
            },
            "auth": null
          },
          "protocolProfileBehavior": {
            "followRedirects": false,
            "followOriginalHttpMethod": false,
            "followAuthorizationHeader": false
          },
          "response": []
        },
        {
          "name": "Create terms",
          "request": {
            "method": "POST",
            "url": {
              "raw": "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/terms/insert/many?terms=true&types=false&defns=false&resolve=true&resfld=_aid&save=true",
              "query": [
                {
                  "key": "terms",
                  "value": "true",
                  "disabled": false,
                  "description": "Expect all object properties to be part of the data dictionary.\nBy default, if a property matches a descriptor, then the value must conform to the descriptor's data definition; if the property does not match a term in the data dictionary, then it will be ignored and assumed correct. If you set this flag, all object properties must correspond to a descriptor, failing to do so will be considered an error."
                },
                {
                  "key": "types",
                  "value": "false",
                  "disabled": false,
                  "description": "Expect all scalar data sections to have the data type.\nBy default, if a scalar data definition section is empty, we assume the value can take any scalar value: if you set this flag, it means that all scalar data definition sections need to indicate the data type, failing to do so will be considered an error."
                },
                {
                  "key": "defns",
                  "value": "false",
                  "disabled": false,
                  "description": "Allow referencing default namespace.\nThe default namespace is reserved to terms that constitute the dictionary engine. User-defined terms should not reference the default namespace. If this option is set, it will be possible to create terms that have the default namespace as their namespace."
                },
                {
                  "key": "resolve",
                  "value": "true",
                  "disabled": false,
                  "description": "Attempt to resolve unmatched term references.\nThis option is relevant to enumerated values. If this flag is set, when a provided value does not resolve into a term global identifier, the value will be tested against the terms code section property indicated in the resfld parameter: if there is a single match, the original value will be replaced by the matched global identifier. This way one can use the local identifier as the reference and let the validator resolve the global identifier.\nWhen this happens the status code will be zero, if no errors have occurred, but the response will feature a property named changes in the status report, which contains the list of resolved values.\nBe aware that to successfully use this feature the local identifiers must be unique."
                },
                {
                  "key": "resfld",
                  "value": "_aid",
                  "disabled": false,
                  "description": "Terms code section field used to resolve term references.\nThis option is relevant if the resolve flag was set. This parameter corresponds to the name of a property in the descriptor's code section: the unresolved value will be matched against the value contained in that field and if there is a single match, the matched term global identifier will replace the provided value.\nBy default this parameter is set to the local identifier, you could set it, for instance, to the list of official identifiers in order to have a larger choice."
                },
                {
                  "key": "save",
                  "value": "true",
                  "disabled": false,
                  "description": "Flag to determine whether to save the term or not.\nThis option can be used when inserting or updating terms: if the flag is set, if all the required validations tests pass, the term will be either inserted or updated. If the flag is not set, you will get the status of the validation provess. This flag is useful if you just need to check if the term is valid, or if you want to see if the updated term structure before persisting the object to the data dictionary."
                }
              ],
              "protocol": null,
              "host": [
                "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/terms/insert/many"
              ],
              "port": null,
              "path": null
            },
            "description": "Use this service to create a list of new terms.\n\n*In order to create terms, the current user must have the `dict` role*.\n\nThis service can be used to create a set of new terms.\n\nWhen inserting the records, the operation is executed transactionally in an *all-or-nothing* fashion.\n\nThe service expects an array of term objects in the body.\n\nEach term is required to have at least the `_code` and `_info` data blocks.\nThe `_code` block is required to have at least the `_lid`. The global identifier will be set, and overwritten, by the service. The list of official identifiers will also be set if missing.\n\nThe `_info` block requires the `_title` and `_definition` properties, the other properties are only provided as placeholders, delete them if not needed. Remember that all elements, except `_provider`, are dictionaries with the *language code* as the dictionary key and the text as the dictionary value, you will have to provide by default the entry in the default language (`language` *entry in the service settings*).\n\nThe `_data` section and the `_rule` section are provided as placeholders, delete them if not needed. You are responsible for their contents.\n\nThe document key will be automatically set and overwritten with the value of the global identifier.\n\nThere are a number of option parameters that govern the service, these are described in the URL parameters section.\n\nIf the service is successful [`200`] it will return a value depending whether the `save` parameter was *set* or not:\n\n- `save` was *set*: The service will return the inserted terms list including the `_id` and the `_rev` properties.\n- `save` was *not set*: The service will return an object structured as follows:\n    - `status`: The status of the operation: `0` for success.\n    - `terms`: The provided list of terms with the global identifier and document key set.\n\nIf the `resolve` parameter was *set* and at least one value in the provided terms was updated, the service will return an HTTP status of [`202`] and object with the following properties:\n\n- `status`: The validation status which is one.\n- `reports`: The status reports, one for each provided term, comprised of the following elements:\n    - `status`: The status report:\n      - `status`: The status code, that will be zero.\n      - `message`: The status message.\n    - `changes`: An object containing the list of resolved fields.\n- `values`: The provided list of terms containing the resolved fields, and the document `_id` and `_rev` properties if the `save` parameter was *set*.\n\nIf the validation failed, the service will return a [`400`] status and an object with the following properties:\n\n- `status`: The validation status which is minus one.\n- `reports`: The list of status reports, one for each provided terms, comprised of the following elements:\n    - `status`: The status report:\n      - `status`: The status code.\n      - `message`: The status message describing the error.\n    - `descriptor`: The name of the property that contains the error.\n    - `value`: The value of the incorrect property\n- `values`: The provided list of terms.\n\nOther status codes are the following:\n\n- `401`: **No current user**: the service will return this code if no user is currently logged in.\n- `403`: **Unauthorised user**: the service will return this code if the current user is not an administrator.\n- `409`: **Term exists**: the service will return this code if the provided term already exists.\n- `500`: For other types of error.\n",
            "header": [],
            "body": {
              "mode": "raw",
              "disabled": false,
              "raw": "[\n  {\n    \"_code\": {\n      \"_lid\": \"test-01\"\n    },\n    \"_info\": {\n      \"_title\": {\n        \"eng\": \"Test term 1\"\n      }\n    },\n    \"_data\": {\n      \"_scalar\": {\n        \"_type\": \"_type_object\"\n      }\n    }\n  },\n  {\n    \"_code\": {\n      \"_lid\": \"test-02\"\n    },\n    \"_info\": {\n      \"_title\": {\n        \"iso_639_3_eng\": \"Test term 2\"\n      }\n    },\n    \"_data\": {\n      \"_scalar\": {\n\t\t\"_type\": \"enum\",\n\t\t\"_kind\": [\"_type\"]\n\t  }\n    }\n  },\n  {\n    \"_code\": {\n      \"_lid\": \"test-03\"\n    },\n    \"_info\": {\n      \"_title\": {\n        \"iso_639_3_eng\": \"Test term 3\"\n      }\n    }\n  }\n]"
            },
            "auth": null
          },
          "protocolProfileBehavior": {
            "followRedirects": false,
            "followOriginalHttpMethod": false,
            "followAuthorizationHeader": false
          },
          "response": []
        },
        {
          "name": "Update term",
          "request": {
            "method": "PATCH",
            "url": {
              "raw": "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/terms?key=test-01&terms=true&types=false&defns=false&resolve=true&resfld=_lid&save=true",
              "query": [
                {
                  "key": "key",
                  "value": "test-01",
                  "disabled": false,
                  "description": "Term global identifier."
                },
                {
                  "key": "terms",
                  "value": "true",
                  "disabled": false,
                  "description": "Expect all object properties to be part of the data dictionary.\nBy default, if a property matches a descriptor, then the value must conform to the descriptor's data definition; if the property does not match a term in the data dictionary, then it will be ignored and assumed correct. If you set this flag, all object properties must correspond to a descriptor, failing to do so will be considered an error."
                },
                {
                  "key": "types",
                  "value": "false",
                  "disabled": false,
                  "description": "Expect all scalar data sections to have the data type.\nBy default, if a scalar data definition section is empty, we assume the value can take any scalar value: if you set this flag, it means that all scalar data definition sections need to indicate the data type, failing to do so will be considered an error."
                },
                {
                  "key": "defns",
                  "value": "false",
                  "disabled": false,
                  "description": "Allow referencing default namespace.\nThe default namespace is reserved to terms that constitute the dictionary engine. User-defined terms should not reference the default namespace. If this option is set, it will be possible to create terms that have the default namespace as their namespace."
                },
                {
                  "key": "resolve",
                  "value": "true",
                  "disabled": false,
                  "description": "Attempt to resolve unmatched term references.\nThis option is relevant to enumerated values. If this flag is set, when a provided value does not resolve into a term global identifier, the value will be tested against the terms code section property indicated in the resfld parameter: if there is a single match, the original value will be replaced by the matched global identifier. This way one can use the local identifier as the reference and let the validator resolve the global identifier.\nWhen this happens the status code will be zero, if no errors have occurred, but the response will feature a property named changes in the status report, which contains the list of resolved values.\nBe aware that to successfully use this feature the local identifiers must be unique."
                },
                {
                  "key": "resfld",
                  "value": "_lid",
                  "disabled": false,
                  "description": "Terms code section field used to resolve term references.\nThis option is relevant if the resolve flag was set. This parameter corresponds to the name of a property in the descriptor's code section: the unresolved value will be matched against the value contained in that field and if there is a single match, the matched term global identifier will replace the provided value.\nBy default this parameter is set to the local identifier, you could set it, for instance, to the list of official identifiers in order to have a larger choice."
                },
                {
                  "key": "save",
                  "value": "true",
                  "disabled": false,
                  "description": "Flag to determine whether to save the term or not.\nThis option can be used when inserting or updating terms: if the flag is set, if all the required validations tests pass, the term will be either inserted or updated. If the flag is not set, you will get the status of the validation process. This flag is useful if you just need to check if the term is valid, or if you want to see if the updated term structure before persisting the object to the data dictionary."
                }
              ],
              "protocol": null,
              "host": [
                "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/terms"
              ],
              "port": null,
              "path": null
            },
            "description": "Use this service to update a term.\n\n*In order to update terms, the current user must have the `dict` role*.\n\nThis service can be used to update an existing term. The body consists of an object with two properties: one contains the *term updates*, the other contains the *list of path keys* to the fields to be updated.\n\nIf the service is successful [`200`] it will return a value depending whether the `save` parameter was *set* or not:\n\n- `save` was *set*: The service will return the updated term including the `_id` and the `_rev` properties.\n- `save` was *not set*: The service will return an object structured as follows:\n    - `status`: The status of the operation: `0` for success.\n    - `term`: The updated term.\n\nIf the `resolve` parameter was *set* and at least one value in the provided term was updated, the service will return an HTTP status of [`202`] and object with the following properties:\n\n- `status`: The validation status which is one.\n- `report`: The status report comprised of the following elements:\n    - `status`: The status report:\n      - `status`: The status code, that will be zero.\n      - `message`: The status message.\n    - `changes`: An object containing the list of resolved fields.\n- `value`: The updated term with the resolved fields.\n\nIf the validation failed, the service will return a [`400`] status and an object with the following properties:\n\n- `status`: The validation status which is minus one.\n- `report`: The status report comprised of the following elements:\n    - `status`: The status report:\n      - `status`: The status code.\n      - `message`: The status message describing the error.\n    - `descriptor`: The name of the property that contains the error.\n    - `value`: The value of the incorrect property\n- `value`: The updated term.\n\nThe service will also assert that the updates, although formally valid, will not reduce the term's options, excluding eventual data associated with the term. In that case the service will fail with a [`400`] HTTP status and return an object structured as follows:\n\n- `status`: The service status message indicating the error is not a validation error.\n- `report`: The status report comprised of the following elements:\n    - `message`: The status message describing the error.\n    - `data`: Original and updated data which triggered the error.\n      - *property name*: The name of the property that triggered the error.\n      - `old`: The original value of the latter property.\n      - `new`: The updated value of the latter property.\n\n\nOther status codes are the following:\n\n- `401`: **No current user**: the service will return this code if no user is currently logged in.\n- `403`: **Unauthorised user**: the service will return this code if the current user is not an administrator.\n- `409`: **Term exists**: the service will return this code if the provided term already exists.\n- `500`: For other types of error.\n",
            "header": [],
            "body": {
              "mode": "raw",
              "disabled": false,
              "raw": "{\n  \"updates\": {\n    \"_code\": {\n      \"_aid\": [\n        \"test_one\"\n      ]\n    },\n    \"_info\": {\n      \"_title\": { \"iso_639_3_ita\": \"Termine di prova uno.\" }\n    }\n  },\n  \"references\": [\n    \"_code._aid\",\n    \"_info._title.iso_639_3_ita\"\n  ]\n}"
            },
            "auth": null
          },
          "protocolProfileBehavior": {
            "followRedirects": false,
            "followOriginalHttpMethod": false,
            "followAuthorizationHeader": false
          },
          "response": []
        },
        {
          "name": "Delete term",
          "request": {
            "method": "DELETE",
            "url": {
              "raw": "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/terms/delete?key=test-01",
              "query": [
                {
                  "key": "key",
                  "value": "test-01",
                  "disabled": false,
                  "description": "Term global identifier."
                }
              ],
              "protocol": null,
              "host": [
                "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/terms/delete"
              ],
              "port": null,
              "path": null
            },
            "description": "Use this service to delete a term.\n\n*In order to delete a term, the current user must have the `dict` role*.\n\nThis service can be used to delete an existing term.\n\nThe service expects the term global identifier as a `key` path query parameter.\n\n**Deleting a term from the data dictionary can have serious consequences, from breaking the integrity of the data dictionary to removing metadata referencing data in other collections or databases. So only use this service if you know what you are doing and you are absolutely sure you want to do it.**\n\n**One safe way to try the service is to create a new term and then delete it.**\n\nIf the service is successful it will return the deleted term identifiers [`200`].\n\nIf the operation does not succeed, the service will return:\n\n- `401`: **No current user**: the service will return this code if no user is currently logged in.\n- `403`: **Unauthorised user**: the service will return this code if the current user is not an administrator.\n- `404`: **Term not found**: the service will return this code if the provided `key` does not match any terms.\n- `500`: For other types of error.",
            "header": [],
            "body": null,
            "auth": null
          },
          "protocolProfileBehavior": {
            "followRedirects": false,
            "followOriginalHttpMethod": false,
            "followAuthorizationHeader": false
          },
          "response": []
        },
        {
          "name": "Delete terms",
          "request": {
            "method": "DELETE",
            "url": {
              "raw": "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/terms/delete/many",
              "query": null,
              "protocol": null,
              "host": [
                "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/terms/delete/many"
              ],
              "port": null,
              "path": null
            },
            "description": "Use this service to delete a list of terms.\n\n*In order to delete terms, the current user must have the `dict` role*.\n\nThis service can be used to delete an list of terms.\n\nThis service can be used to remove the terms matching the provided list of global identifiers in the body. The value should correspond to the `_gid` property in the *code section*, which corresponds to the record `_key`.\n\n**Deleting a term from the data dictionary can have serious consequences, from breaking the integrity of the data dictionary to removing metadata referencing data in other collections or databases. So only use this service if you know what you are doing and you are absolutely sure you want to do it.**\n\n**One safe way to try the service is to create a new term and then delete it.**\n\nIf the service is successful it will return the number of deleted terms and the number of ignored keys [`200`].\n\nIf the operation does not succeed, the service will return:\n\n- `401`: **No current user**: the service will return this code if no user is currently logged in.\n- `403`: **Unauthorised user**: the service will return this code if the current user is not an administrator.\n- `500`: For other types of error.",
            "header": [],
            "body": {
              "mode": "raw",
              "disabled": false,
              "raw": "[\n  \"test-01\",\n  \"test-02\",\n  \"INKNOWN TERM\"\n]"
            },
            "auth": null
          },
          "protocolProfileBehavior": {
            "followRedirects": false,
            "followOriginalHttpMethod": false,
            "followAuthorizationHeader": false
          },
          "response": []
        },
        {
          "name": "Get term by key",
          "request": {
            "method": "GET",
            "url": {
              "raw": "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/terms?key=_type&lang=iso_639_3_eng",
              "query": [
                {
                  "key": "key",
                  "value": "_type",
                  "disabled": false,
                  "description": "Term global identifier."
                },
                {
                  "key": "lang",
                  "value": "iso_639_3_eng",
                  "disabled": false,
                  "description": "Language code for descriptions."
                }
              ],
              "protocol": null,
              "host": [
                "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/terms"
              ],
              "port": null,
              "path": null
            },
            "description": "Use this service to get a specific term.\n\n*In order to consult a term, the current user must have the `read` role*.\n\nThis service can be used to retrieve the term record matching the provided term global identifier.\n\nThe service expects two path query parameters:\n\n- `key`: It represents the term `_key`, or *global identifier*.\n- `lang`: The *language code* for the description texts; the field will be set with the default language, or pass `@` to get the result in all languages.\n\nIf the service is successful it will return the term record matching the provided global identifier [`200`].\n\nIf the operation does not succeed, the service will return:\n\n- `401`: **No current user**: the service will return this code if no user is currently logged in.\n- `403`: **Unauthorised user**: the service will return this code if the current user is not an administrator.\n- `404`: **Term not found**: the service will return this code if the provided term does not exist.\n- `500`: For other types of error.",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json",
                "disabled": false,
                "description": null
              }
            ],
            "body": {
              "mode": "raw",
              "disabled": false,
              "raw": "{\"start\":0,\"limit\":25,\"username\":\"test\",\"role\":[\"read\"],\"default\":false}"
            },
            "auth": null
          },
          "protocolProfileBehavior": {
            "followRedirects": false,
            "followOriginalHttpMethod": false,
            "followAuthorizationHeader": false
          },
          "response": []
        },
        {
          "name": "Get terms by key",
          "request": {
            "method": "POST",
            "url": {
              "raw": "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/terms/dict?lang=iso_639_3_eng",
              "query": [
                {
                  "key": "lang",
                  "value": "iso_639_3_eng",
                  "disabled": false,
                  "description": "Language code for descriptions."
                }
              ],
              "protocol": null,
              "host": [
                "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/terms/dict"
              ],
              "port": null,
              "path": null
            },
            "description": "Use this service to get a list of terms.\n\n*In order to consult a term, the current user must have the `read` role*.\n\nThis service can be used to retrieve the term records matching the provided list of term global identifiers.\n\nThe service expects a path query parameter, `lang`, the *language code* for the description texts; the field will be set with the default language, or pass `@` to get the result in all languages.\n\nThe service expects the list of term global identifiers to be provided in the body as an array.\n\nIf the service is successful, [`200`], it will return a key/value dictionary in which the key represents the provided term global identifier and the value the matched term record. If the identifier is not matched, the value will be `null`.\n\nIf the operation does not succeed, the service will return:\n\n- `401`: **No current user**: the service will return this code if no user is currently logged in.\n- `403`: **Unauthorised user**: the service will return this code if the current user is not an administrator.\n- `500`: For other types of error.",
            "header": [],
            "body": {
              "mode": "raw",
              "disabled": false,
              "raw": "[\n  \"_type\",\n  \"_code\",\n  \"UNKNOWN\"\n]"
            },
            "auth": null
          },
          "protocolProfileBehavior": {
            "followRedirects": false,
            "followOriginalHttpMethod": false,
            "followAuthorizationHeader": false
          },
          "response": []
        },
        {
          "name": "Query term keys",
          "request": {
            "method": "POST",
            "url": {
              "raw": "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/terms/query/keys",
              "query": null,
              "protocol": null,
              "host": [
                "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/terms/query/keys"
              ],
              "port": null,
              "path": null
            },
            "description": "Query terms returning keys.\n\n*In order to use this service, the current user must have the `read` role*.\n\nThis service can be used to retrieve a list of term global identifiers according to a selection criteria.\n\nThe request body contains an object that can be used to select from a set of properties:\n\n- `start`: Start position in results.\n- `limit`: Number of elements to be returned.\n- `term_type`: Select `descriptor` for *descriptors*, `structure` for *structure types* or any other value for *all types*.\n- `_nid`: Term *namespace*, wildcard match.\n- `_lid`: Term *local identifier*, wildcard match.\n- `_gid`: Term *global identifier*, wildcard match.\n- `_name`: Term *global identifier*, wildcard match.\n- `_aid`: List of *extended local identifiers*, exact match.\n- `_pid`: Term *global identifier*, wildcard match.\n- `_title`: Term *label or title*, provide a string with space delimited tokens.\n- `_definition`: Term *definition*, provide a string with space delimited tokens.\n- `_description`: Term *description*, provide a string with space delimited tokens.\n- `_examples`: Term *usage examples*, provide a string with space delimited tokens.\n- `_notes`: Term *notes*, provide a string with space delimited tokens.\n- `_provider`: Term *provider*, provide a string with space delimited tokens.\n\nFor all string fields the supported wildcards are `_` to match a *single arbitrary character*, and `%` to match *any number of arbitrary characters*. Literal `%` and `_` need to be escaped with a backslash. Backslashes need to be escaped themselves.\n\nFor all token match fields provide a string with space delimited tokens.\n\nAny selector can be omitted, except `start` and `limit`.\n\nIf the operation succeeds the service will return the list of matching term global identifiers [`200`], if the operation fails:\n\n- `401`: **No current user**: the service will return this code if no user is currently logged in.\n- `403`: **Unauthorised user**: the service will return this code if the current user is not an administrator.\n- `500`: For all other errors.\n",
            "header": [],
            "body": {
              "mode": "raw",
              "disabled": false,
              "raw": "{\n  \"start\": 0,\n  \"limit\": 25,\n  \"term_type\": \"descriptor\",\n  \"_lid\": \"type\",\n  \"_gid\": \"_type\",\n  \"_aid\": [\n    \"type\"\n  ],\n  \"_title\": \"type\",\n  \"_definition\": \"data type\"\n}"
            },
            "auth": null
          },
          "protocolProfileBehavior": {
            "followRedirects": false,
            "followOriginalHttpMethod": false,
            "followAuthorizationHeader": false
          },
          "response": []
        },
        {
          "name": "Query term records",
          "request": {
            "method": "POST",
            "url": {
              "raw": "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/terms/query/terms?lang=iso_639_3_eng",
              "query": [
                {
                  "key": "lang",
                  "value": "iso_639_3_eng",
                  "disabled": false,
                  "description": "Language code for multi-language strings."
                }
              ],
              "protocol": null,
              "host": [
                "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/terms/query/terms"
              ],
              "port": null,
              "path": null
            },
            "description": "Query terms returning records.\n\n*In order to use this service, the current user must have the `read` role*.\n\nThis service can be used to retrieve a list of terms according to a selection criteria.\n\nThe service expects the language code for descriptions in the path query parameter `lang`: the titles and descriptions of the terms will be returned in that language, or they will be returned unaltered if the language code doesn't match any entry, or if you provide `@`.\n\nThe request body contains an object that can be used to select from a set of properties:\n\n- `start`: Start position in results.\n- `limit`: Number of elements to be returned.\n- `term_type`: Select `descriptor` for *descriptors*, `structure` for *structure types* or any other value for *all types*.\n- `_nid`: Term *namespace*, wildcard match.\n- `_lid`: Term *local identifier*, wildcard match.\n- `_gid`: Term *global identifier*, wildcard match.\n- `_name`: Term *global identifier*, wildcard match.\n- `_aid`: List of *extended local identifiers*, exact match.\n- `_pid`: Term *global identifier*, wildcard match.\n- `_title`: Term *label or title*, provide a string with space delimited tokens.\n- `_definition`: Term *definition*, provide a string with space delimited tokens.\n- `_description`: Term *description*, provide a string with space delimited tokens.\n- `_examples`: Term *usage examples*, provide a string with space delimited tokens.\n- `_notes`: Term *notes*, provide a string with space delimited tokens.\n- `_provider`: Term *provider*, provide a string with space delimited tokens.\n\nFor all string fields the supported wildcards are `_` to match a *single arbitrary character*, and `%` to match *any number of arbitrary characters*. Literal `%` and `_` need to be escaped with a backslash. Backslashes need to be escaped themselves.\n\nFor all token match fields provide a string with space delimited tokens.\n\nAny selector can be omitted, except `start` and `limit`.\n\nIf the operation succeeds the service will return the list of matching terms [`200`], if the operation fails:\n\n- `401`: **No current user**: the service will return this code if no user is currently logged in.\n- `403`: **Unauthorised user**: the service will return this code if the current user is not an administrator.\n- `500`: For all other errors.\n",
            "header": [],
            "body": {
              "mode": "raw",
              "disabled": false,
              "raw": "{\n  \"start\": 0,\n  \"limit\": 25,\n  \"term_type\": \"descriptor\",\n  \"_lid\": \"type\",\n  \"_gid\": \"_type\",\n  \"_aid\": [\n    \"type\"\n  ],\n  \"_title\": \"type\",\n  \"_definition\": \"data type\"\n}"
            },
            "auth": null
          },
          "protocolProfileBehavior": {
            "followRedirects": false,
            "followOriginalHttpMethod": false,
            "followAuthorizationHeader": false
          },
          "response": []
        }
      ],
      "protocolProfileBehavior": null,
      "response": []
    },
    {
      "name": "GRAPHS",
      "item": [
        {
          "name": "Set edges",
          "request": {
            "method": "POST",
            "url": {
              "raw": "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/graph/set/edge?root=terms/_type&parent=terms/_type_string&predicate=_predicate_enum-of&direction=true&save=false&inserted=true&updated=true&existing=true",
              "query": [
                {
                  "key": "root",
                  "value": "terms/_type",
                  "disabled": false,
                  "description": "This parameter represents the document handle of the graph root node. The root, along with the functional predicate, identifies the path that traverses the current edge."
                },
                {
                  "key": "parent",
                  "value": "terms/_type_string",
                  "disabled": false,
                  "description": "This parameter represents the document handle of the node that represents the parent to which the child nodes point to, or that points to the child nodes."
                },
                {
                  "key": "predicate",
                  "value": "_predicate_enum-of",
                  "disabled": false,
                  "description": "This parameter represents the functional predicate of the current edge. A functional predicate determines what function the child node has. Here are a couple of examples:\n- _predicate_enum-of: Valid enumeration element.\n- _predicate_field-of: Valid field element.\n- _predicate_property-of: Valid property element."
                },
                {
                  "key": "direction",
                  "value": "true",
                  "disabled": false,
                  "description": "This parameter determines the direction of relationships for the provided predicate: true indicates that children point to the parent, false indicates that the parent points to the children. By default this parameter assumes many to one relationships, true. *Note that the direction should be consistent with all predicates used in the graph."
                },
                {
                  "key": "save",
                  "value": "false",
                  "disabled": false,
                  "description": "If set, the edges will be created, updated or deleted; if not set, the service will only return information on potential operations."
                },
                {
                  "key": "inserted",
                  "value": "true",
                  "disabled": false,
                  "description": "If set, the the service will return the list of inserted edges, if not set, the service will only return operation statistics."
                },
                {
                  "key": "updated",
                  "value": "true",
                  "disabled": false,
                  "description": "If set, the the service will return the list of updated edges, if not set, the service will only return operation statistics."
                },
                {
                  "key": "existing",
                  "value": "true",
                  "disabled": false,
                  "description": "If set, the the service will return the list of existing edges, if not set, the service will only return operation statistics."
                }
              ],
              "protocol": null,
              "host": [
                "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/graph/set/edge"
              ],
              "port": null,
              "path": null
            },
            "description": "*In order to use this service, the current user must have the `dict` role*.\n\nGraphs are networks of nodes connected to each other by edges. An edge is uniquely identified by its subject-predicate-object relationship. This means that many paths can traverse the same edge: these paths are identified by the graph root node, and the functional predicate characterising its path.\n\nPredicates are of three types: functional, container and bridge. Functional predicates determine what the current graph represents: a controlled vocabulary, a data structure type, etc. Nodes connected with such predicates are valid choices for that predicate. Container predicates are used to group child nodes under a common category that has no function, other\nthan to collect a set of choices. Bridge predicates are used to allow another graph (different root) to share the structure of the current graph. Edges also feature an object property that holds data that can be used during traversals.\n\nThis service can be used to create edges with functional predicates. The service expects the graph root node reference, which identifies the graph path, the parent and children node references to be connected, the functional predicate, the list of section predicates expected during traversals, the custom data associated with the edge and a set of flags governing the operation.\n\nThe request body should be provided with an object containing the following elements:\n\n- `children`: A key/value dictionary in which the key represents the child node document handle and the value represents custom data associated with the corresponding edge.\n  - `sections`: Graphs have predicates that indicate the type of graph: enumeration, field, etc. There are other predicates, however, whose goal is to link nodes which\nwill not have the function of the main predicate. The provided default values indicate sections, that represent display or category nodes used for subdividing child nodes, and bridges, which allow one node to connect to another node through a bridge node.\n\nThe values of the children dictionary can be the following:\n\n- `object`: This represents valid data for the edge, the provided object will be merged with the existing one. If you set a provided property value to null, if the property exists in the edge data, the service will delete that property from the existing data. If you want to ignore the value, pass an empty object.\n- `null`: If you provide this value the whole custom data container will be reset to an empty object.\n\nIf the edge does not exist, the provided data will be set in the edge, except for the properties that have a null value. If the edge exists, the parameters of the provided data will replace eventual existing matching parameters, or will be erased, if the value is null.\n\nThe service will do the following:\n\n- Assert that the parent node is connected to the root node.\n- If the subject-predicate-object combination does not exist, it will create an edge with the combination of the provided parent, the provided predicate and the current child, for the provided root. If custom data was provided, it will be set, or an empty object will be set.\n- If the subject-predicate-object combination exists:\n    - If the root is not among the paths it will be added, and the eventual custom data will replace or reset existing data.\n    - If the root is in the list of paths, the service will only handle the edge data.\n\nIf the service is successful, [`200`], it will return an object containign the following properties:\n\n  - `stats`:\n    - `inserted`: The number of inserted edges.\n    - `updated`: The number of updated edges.\n    - `existing`: The number of ignored existing edges.\n  - `inserted`: The list of inserted edges, if the inserted parameter was set.\n  - `updated`: The list of updated edger, if the updated \\ parameter was set.\n  - `existing`: The list of existing edges, if the existing parameter was set.\n\n\nIf the operation does not succeed, the service will return:\n\n- `400`: **Invalid reference**: the service will return this code if any provided term reference is invalid.\n- `401`: **No current user**: the service will return this code if no user is currently logged in.\n- `403`: **Unauthorised user**: the service will return this code if the current user is not an administrator.\n- `500`: For other types of error.",
            "header": [],
            "body": {
              "mode": "raw",
              "disabled": false,
              "raw": "{\n  \"children\": {\n    \"terms/_predicate_enum-of\": {\"_name\": \"Enumeration\"},\n    \"terms/_predicate_field-of\": {\"_name\": \"Field.\"},\n    \"terms/_type_string_enum\": {\"_title\": {\"iso_639_3_eng\": \"This is custom data.\"}},\n    \"terms/_type_string_key\": null\n  },\n  \"sections\": [\n    \"_predicate_section-of\",\n    \"_predicate_bridge-of\"\n  ]\n}"
            },
            "auth": null
          },
          "protocolProfileBehavior": {
            "followRedirects": false,
            "followOriginalHttpMethod": false,
            "followAuthorizationHeader": false
          },
          "response": []
        },
        {
          "name": "Delete edges",
          "request": {
            "method": "POST",
            "url": {
              "raw": "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/graph/del/edge?root=terms/_type&parent=terms/_type&predicate=_predicate_enum-of&direction=true&save=false&prune=false&deleted=true&updated=true&ignored=true",
              "query": [
                {
                  "key": "root",
                  "value": "terms/_type",
                  "disabled": false,
                  "description": "This parameter represents the document handle of the graph root node. The root, along with the functional predicate, identifies the path that traverses the current edge."
                },
                {
                  "key": "parent",
                  "value": "terms/_type",
                  "disabled": false,
                  "description": "This parameter represents the document handle of the node that represents the parent to which the child nodes point to, or that points to the child nodes."
                },
                {
                  "key": "predicate",
                  "value": "_predicate_enum-of",
                  "disabled": false,
                  "description": "This parameter represents the functional predicate of the current edge. A functional predicate determines what function the child node has. Here are a couple of examples:\n- _predicate_enum-of: Valid enumeration element.\n- _predicate_field-of: Valid field element.\n- _predicate_property-of: Valid property element."
                },
                {
                  "key": "direction",
                  "value": "true",
                  "disabled": false,
                  "description": "This parameter determines the direction of relationships for the provided predicate: true indicates that children point to the parent, false indicates that the parent points to the children. By default this parameter assumes many to one relationships, true. *Note that the direction should be consistent with all predicates used in the graph."
                },
                {
                  "key": "save",
                  "value": "false",
                  "disabled": false,
                  "description": "If set, the edges will be created, updated or deleted; if not set, the service will only return information on potential operations."
                },
                {
                  "key": "prune",
                  "value": "false",
                  "disabled": false,
                  "description": "This parameter is used when deleting edges: if set, after deleting the edges connecting parent to chindren, all edges from children to leaf nodes will also be deleted, preventing dangling relationships; if not set, branches originating from child nodes will be left intact, which can be useful if you want to attach the children to another parent."
                },
                {
                  "key": "deleted",
                  "value": "true",
                  "disabled": false,
                  "description": "If set, the the service will return the list of deleted edges, if not set, the service will only return operation statistics."
                },
                {
                  "key": "updated",
                  "value": "true",
                  "disabled": false,
                  "description": "If set, the the service will return the list of updated edges, if not set, the service will only return operation statistics."
                },
                {
                  "key": "ignored",
                  "value": "true",
                  "disabled": false,
                  "description": "If set, the the service will return the list of existing edges, if not set, the service will only return operation statistics."
                }
              ],
              "protocol": null,
              "host": [
                "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/graph/del/edge"
              ],
              "port": null,
              "path": null
            },
            "description": "*In order to use this service, the current user must have the `dict` role*.\n\nGraphs are networks of nodes connected to each other by edges. An edge is uniquely identified by its subject-predicate-object relationship. This means that many paths can traverse the same edge: these paths are identified by the graph root node, and the functional predicate characterising its path.\n\nPredicates are of three types: functional, container and bridge. Functional predicates determine what the current graph represents: a controlled vocabulary, a data structure type, etc. Nodes connected with such predicates are valid choices for that predicate. Container predicates are used to group child nodes under a common category that has no function, other\nthan to collect a set of choices. Bridge predicates are used to allow another graph (different root) to share the structure of the current graph. Edges also feature an object property that holds data that can be used during traversals.\n\nThis service can be used to delete edges with functional predicates. The service expects the graph root node reference, which identifies the graph path, the parent and children node references to be connected, the functional predicate, the list of section predicates expected during traversals, the custom data associated with the edge and a set of flags governing the operation.\n\nThe request body should be provided with an object containing the following elements:\n\n- `children`: A key/value dictionary in which the key represents the child nodedocument handle and the value represents custom data associated with the corresponding edge.\n- `sections`: Graphs have predicates that indicate the type of graph: enumeration, field, etc. There are other predicates, however, whose goal is to link nodes which will not have the function of the main predicate. The provided default values indicate sections, that represent display or category nodes used for subdividing child nodes, and bridges, which allow one node to connect to another node through a bridge node.\n\nThe values of the children dictionary can be the following:\n\n- `object`: This represents valid data for the edge, the provided object will be merged with the existing one. If you set a provided property value to null, if the property exists in the edge data, the service will delete that property from the existing data. If you want to ignore the value, pass an empty object.\n- `null`: If you provide this value the whole custom data container will be reset to an empty object.\n\nIf the edge exists, the provided root is removed from the edge path: if there are elements left in the path, the parameters of the provided data will replace eventual existing matching parameters, or will be erased, if the value is null.\n\nThe service will do the following:\n\n- Locate the edge containing the current child pointing to the parent.\n- Remove the current root from the list of roots in the edge path:\n    - If the path becomes empty:\n      - Delete the edge.\n      - If the prune parameter is set:\n        - Recurse the operation for all branches stemming from the child node.\n    - If the path is not empty:\n      - Ignore, reset or set the edge data.\n      - Update the edge.\n\n*Note: this service will only remove the relationships, the nodes will not be deleted. It is the responsibility of the caller to manage orphans. Eventual root bridge predicates might be left dangling: this is intended, since one could connect these dangling relationships after the deletions. Finally, edges that do not feature the provided root will be ignored, meaning that custom edge data will be left untouched: this is intended, since custom edge data is implicitly connected to the graph root.*\n\nIf the service is successful, [`200`], it will return an object containign the following properties:\n\n  - `stats`:\n    - `inserted`: The number of inserted edges.\n    - `updated`: The number of updated edges.\n    - `existing`: The number of ignored existing edges.\n  - `inserted`: The list of inserted edges, if the inserted parameter was set.\n  - `updated`: The list of updated edger, if the updated \\ parameter was set.\n  - `existing`: The list of existing edges, if the existing parameter was set.\n\n\nIf the operation does not succeed, the service will return:\n\n- `400`: **Invalid reference**: the service will return this code if any provided term reference is invalid.\n- `401`: **No current user**: the service will return this code if no user is currently logged in.\n- `403`: **Unauthorised user**: the service will return this code if the current user is not an administrator.\n- `500`: For other types of error.",
            "header": [],
            "body": {
              "mode": "raw",
              "disabled": false,
              "raw": "{\n  \"children\": {\n    \"terms/_type_string\": {\"_name\": \"Pippo\"},\n    \"terms/_type_string_enum\": null,\n    \"terms/_type_number\": null\n  },\n  \"sections\": [\n    \"_predicate_section-of\",\n    \"_predicate_bridge-of\"\n  ]\n}"
            },
            "auth": null
          },
          "protocolProfileBehavior": {
            "followRedirects": false,
            "followOriginalHttpMethod": false,
            "followAuthorizationHeader": false
          },
          "response": []
        },
        {
          "name": "Set containers",
          "request": {
            "method": "POST",
            "url": {
              "raw": "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/graph/set/container?root=terms/_type&parent=terms/_type_string&container=_predicate_section-of&predicate=_predicate_enum-of&direction=true&save=false&inserted=true&updated=true&existing=true",
              "query": [
                {
                  "key": "root",
                  "value": "terms/_type",
                  "disabled": false,
                  "description": "This parameter represents the document handle of the graph root node. The root, along with the functional predicate, identifies the path that traverses the current edge."
                },
                {
                  "key": "parent",
                  "value": "terms/_type_string",
                  "disabled": false,
                  "description": "This parameter represents the document handle of the node that represents the parent to which the child nodes point to, or that points to the child nodes."
                },
                {
                  "key": "container",
                  "value": "_predicate_section-of",
                  "disabled": false,
                  "description": "This parameter represents the container predicate to be used in the current operation. A container predicate does not have any specific function, except that of serving as a container or common category for a set of children. Here is an example:\n- _predicate_section-of: The target node is a section, not a functional element."
                },
                {
                  "key": "predicate",
                  "value": "_predicate_enum-of",
                  "disabled": false,
                  "description": "This parameter represents the functional predicate of the current edge. A functional predicate determines what function the child node has. Here are a couple of examples:\n- _predicate_enum-of: Valid enumeration element.\n- _predicate_field-of: Valid field element.\n- _predicate_property-of: Valid property element."
                },
                {
                  "key": "direction",
                  "value": "true",
                  "disabled": false,
                  "description": "This parameter determines the direction of relationships for the provided predicate: true indicates that children point to the parent, false indicates that the parent points to the children. By default this parameter assumes many to one relationships, true. *Note that the direction should be consistent with all predicates used in the graph."
                },
                {
                  "key": "save",
                  "value": "false",
                  "disabled": false,
                  "description": "If set, the edges will be created, updated or deleted; if not set, the service will only return information on potential operations."
                },
                {
                  "key": "inserted",
                  "value": "true",
                  "disabled": false,
                  "description": "If set, the the service will return the list of inserted edges, if not set, the service will only return operation statistics."
                },
                {
                  "key": "updated",
                  "value": "true",
                  "disabled": false,
                  "description": "If set, the the service will return the list of updated edges, if not set, the service will only return operation statistics."
                },
                {
                  "key": "existing",
                  "value": "true",
                  "disabled": false,
                  "description": "If set, the the service will return the list of existing edges, if not set, the service will only return operation statistics."
                }
              ],
              "protocol": null,
              "host": [
                "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/graph/set/container"
              ],
              "port": null,
              "path": null
            },
            "description": "*In order to use this service, the current user must have the `dict` role*.\n\nGraphs are networks of nodes connected to each other by edges. An edge is uniquely identified by its subject-predicate-object relationship. This means that many paths can traverse the same edge: these paths are identified by the graph root node, and the functional predicate characterising its path.\n\nPredicates are of three types: functional, container and bridge. Functional predicates determine what the current graph represents: a controlled vocabulary, a data structure type, etc. Nodes connected with such predicates are valid choices for that predicate. Container predicates are used to group child nodes under a common category that has no function, other\nthan to collect a set of choices. Bridge predicates are used to allow another graph (different root) to share the structure of the current graph. Edges also feature an object property that holds data that can be used during traversals.\n\nThis service can be used to create edges with container predicates. The service expects the graph root node reference, which identifies the graph path, the parent and children node references to be connected, the functional predicate which identifies the functional paths of the graph, the container predicate to be set, the list of section and bridge predicates expected during traversals, the custom data associated with the edge and a set of flags governing the operation.\n\nThe request body should be provided with an object containing the following elements:\n\n- `children`: A key/value dictionary in which the key represents the child node document handle and the value represents custom data associated with the corresponding edge.\n- `sections`: Graphs have predicates that indicate the type of graph: enumeration, field, etc. There are other predicates, however, whose goal is to link nodes which\nwill not have the function of the main predicate. The provided default values indicate sections, that represent display or category nodes used for subdividing child nodes, and bridges, which allow one node to connect to another node through a bridge node.\n\nThe values of the children dictionary can be the following:\n\n- `object`: This represents valid data for the edge, the provided object will be merged with the existing one. If you set a provided property value to null, if the property exists in the edge data, the service will delete that property from the existing data. If you want to ignore the value, pass an empty object.\n- `null`: If you provide this value the whole custom data container will be reset to an empty object.\n\nIf the edge does not exist, the provided data will be set in the edge, except for the properties that have a null value. If the edge exists, the parameters of the provided data will replace eventual existing matching parameters, or will be erased, if the value is null.\n\nThe service will do the following:\n\n- Assert that the parent node is connected to the root node.\n- If the subject-predicate-object combination does not exist, it will create an edge with the combination of the provided parent, the container predicate and the current child, for the provided root. If custom data was provided, it will be set, or an empty object will be set.\n- If the subject-predicate-object combination exists:\n    - If the root is not among the paths it will be added, and the eventual custom data will replace or reset existing data.\n    - If the root is in the list of paths, the service will only handle the edge data.\n\nIf the service is successful, [`200`], it will return an object containign the following properties:\n\n  - `stats`:\n    - `inserted`: The number of inserted edges.\n    - `updated`: The number of updated edges.\n    - `existing`: The number of ignored existing edges.\n  - `inserted`: The list of inserted edges, if the inserted parameter was set.\n  - `updated`: The list of updated edger, if the updated \\ parameter was set.\n  - `existing`: The list of existing edges, if the existing parameter was set.\n\n\nIf the operation does not succeed, the service will return:\n\n- `400`: **Invalid reference**: the service will return this code if any provided term reference is invalid.\n- `401`: **No current user**: the service will return this code if no user is currently logged in.\n- `403`: **Unauthorised user**: the service will return this code if the current user is not an administrator.\n- `500`: For other types of error.",
            "header": [],
            "body": {
              "mode": "raw",
              "disabled": false,
              "raw": "{\n  \"children\": {\n    \"terms/_type_string_enum\": {\"_name\": \"Enumeration type.\"}\n  },\n  \"sections\": [\n    \"_predicate_section-of\",\n    \"_predicate_bridge-of\"\n  ]\n}"
            },
            "auth": null
          },
          "protocolProfileBehavior": {
            "followRedirects": false,
            "followOriginalHttpMethod": false,
            "followAuthorizationHeader": false
          },
          "response": []
        },
        {
          "name": "Delete containers",
          "request": {
            "method": "POST",
            "url": {
              "raw": "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/graph/del/container?root=terms/_predicate&parent=terms/_predicate&container=_predicate_section-of&predicate=_predicate_enum-of&direction=true&save=false&prune=true&deleted=true&updated=true&ignored=true",
              "query": [
                {
                  "key": "root",
                  "value": "terms/_predicate",
                  "disabled": false,
                  "description": "This parameter represents the document handle of the graph root node. The root, along with the functional predicate, identifies the path that traverses the current edge."
                },
                {
                  "key": "parent",
                  "value": "terms/_predicate",
                  "disabled": false,
                  "description": "This parameter represents the document handle of the node that represents the parent to which the child nodes point to, or that points to the child nodes."
                },
                {
                  "key": "container",
                  "value": "_predicate_section-of",
                  "disabled": false,
                  "description": "This parameter represents the container predicate to be used in the current operation. A container predicate does not have any specific function, except that of serving as a container or common category for a set of children. Here is an example:\n- _predicate_section-of: The target node is a section, not a functional element.\nDefault value : _predicate_section-of"
                },
                {
                  "key": "predicate",
                  "value": "_predicate_enum-of",
                  "disabled": false,
                  "description": "This parameter represents the functional predicate of the current edge. A functional predicate determines what function the child node has. Here are a couple of examples:\n- _predicate_enum-of: Valid enumeration element.\n- _predicate_field-of: Valid field element.\n- _predicate_property-of: Valid property element."
                },
                {
                  "key": "direction",
                  "value": "true",
                  "disabled": false,
                  "description": "This parameter determines the direction of relationships for the provided predicate: true indicates that children point to the parent, false indicates that the parent points to the children. By default this parameter assumes many to one relationships, true. *Note that the direction should be consistent with all predicates used in the graph."
                },
                {
                  "key": "save",
                  "value": "false",
                  "disabled": false,
                  "description": "If set, the edges will be created, updated or deleted; if not set, the service will only return information on potential operations."
                },
                {
                  "key": "prune",
                  "value": "true",
                  "disabled": false,
                  "description": "This parameter is used when deleting edges: if set, after deleting the edges connecting parent to chindren, all edges from children to leaf nodes will also be deleted, preventing dangling relationships; if not set, branches originating from child nodes will be left intact, which can be useful if you want to attach the children to another parent."
                },
                {
                  "key": "deleted",
                  "value": "true",
                  "disabled": false,
                  "description": "If set, the the service will return the list of deleted edges, if not set, the service will only return operation statistics."
                },
                {
                  "key": "updated",
                  "value": "true",
                  "disabled": false,
                  "description": "If set, the the service will return the list of updated edges, if not set, the service will only return operation statistics."
                },
                {
                  "key": "ignored",
                  "value": "true",
                  "disabled": false,
                  "description": "If set, the the service will return the list of existing edges, if not set, the service will only return operation statistics."
                }
              ],
              "protocol": null,
              "host": [
                "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/graph/del/container"
              ],
              "port": null,
              "path": null
            },
            "description": "*In order to use this service, the current user must have the `dict` role*.\n\nGraphs are networks of nodes connected to each other by edges. An edge is uniquely identified by its subject-predicate-object relationship. This means that many paths can traverse the same edge: these paths are identified by the graph root node, and the functional predicate characterising its path.\n\nPredicates are of three types: functional, container and bridge. Functional predicates determine what the current graph represents: a controlled vocabulary, a data structure type, etc. Nodes connected with such predicates are valid choices for that predicate. Container predicates are used to group child nodes under a common category that has no function, other\nthan to collect a set of choices. Bridge predicates are used to allow another graph (different root) to share the structure of the current graph. Edges also feature an object property that holds data that can be used during traversals.\n\nThis service can be used to delete edges with container predicates. The service expects the graph root node reference, which identifies the graph path, the parent and children node references to be connected, the functional predicate which identifies the functional paths of the graph, the container predicate to be matched, the list of section and bridge predicates expected during traversals, the custom data associated with the edge and a set of flags governing the operation.\n\nThe request body should be provided with an object containing the following elements:\n\n- `children`: A key/value dictionary in which the key represents the child node document handle and the value represents custom data associated with the corresponding edge.\n- `sections`: Graphs have predicates that indicate the type of graph: enumeration, field, etc. There are other predicates, however, whose goal is to link nodes which will not have the function of the main predicate. The provided default values indicate sections, that represent display or category nodes used for subdividing child nodes, and bridges, which allow one node to connect to another node through a bridge node.\n\nThe values of the children dictionary can be the following:\n\n- `object`: This represents valid data for the edge, the provided object will be merged with the existing one. If you set a provided property value to null, if the property exists in the edge data, the service will delete that property from the existing data. If you want to ignore the value, pass an empty object.\n- `null`: If you provide this value the whole custom data container will be reset to an empty object.\n\nIf the edge exists, the provided root is removed from the edge path: if there are elements left in the path, the parameters of the provided data will replace eventual existing matching parameters, or will be erased, if the value is null.\n\nThe service will do the following:\n\n- Locate the edge containing the current child pointing to the parent.\n- Remove the current root from the list of roots in the edge path:\n    - If the path becomes empty:\n      - Delete the edge.\n      - If the prune parameter is set:\n        - Recurse the operation for all branches stemming from the child node. *Note that the predicates used to traverse the graph will be the provided functional predicate and list of section predicates*.\n    - If the path is not empty:\n      - Ignore, reset or set the edge data.\n      - Update the edge.\n\n*Note: this service will only remove the relationships, the nodes will not be deleted. It is the responsibility of the caller to manage orphans. Eventual root bridge predicates might be left dangling: this is intended, since one could connect these dangling relationships after the deletions. Finally, edges that do not feature the provided root will be ignored, meaning that custom edge data will be left untouched: this is intended, since custom edge data is implicitly connected to the graph root.*\n\nIf the service is successful, [`200`], it will return an object containign the following properties:\n\n  - `stats`:\n    - `inserted`: The number of inserted edges.\n    - `updated`: The number of updated edges.\n    - `existing`: The number of ignored existing edges.\n  - `inserted`: The list of inserted edges, if the inserted parameter was set.\n  - `updated`: The list of updated edger, if the updated \\ parameter was set.\n  - `existing`: The list of existing edges, if the existing parameter was set.\n\n\nIf the operation does not succeed, the service will return:\n\n- `400`: **Invalid reference**: the service will return this code if any provided term reference is invalid.\n- `401`: **No current user**: the service will return this code if no user is currently logged in.\n- `403`: **Unauthorised user**: the service will return this code if the current user is not an administrator.\n- `500`: For other types of error.",
            "header": [],
            "body": {
              "mode": "raw",
              "disabled": false,
              "raw": "{\n  \"children\": {\n    \"terms/_predicate_functional\": null,\n    \"terms/_predicate_requires\": {\"_name\": \"Custom data.\"},\n    \"terms/_type_string\": null\n  },\n  \"sections\": [\n    \"_predicate_section-of\",\n    \"_predicate_bridge-of\"\n  ]\n}"
            },
            "auth": null
          },
          "protocolProfileBehavior": {
            "followRedirects": false,
            "followOriginalHttpMethod": false,
            "followAuthorizationHeader": false
          },
          "response": []
        },
        {
          "name": "Set bridge",
          "request": {
            "method": "POST",
            "url": {
              "raw": "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/graph/set/bridge?root=terms/_predicate&bridged=terms/_type&bridge=_predicate_bridge-of&direction=true&save=false&inserted=true&updated=true&existing=true",
              "query": [
                {
                  "key": "root",
                  "value": "terms/_predicate",
                  "disabled": false,
                  "description": "This parameter represents the document handle of the graph root node. The root identifies the path that traverses the current edge."
                },
                {
                  "key": "bridged",
                  "value": "terms/_type",
                  "disabled": false,
                  "description": "This parameter represents the document handle of the node that will become the bridge for the root node. If node A wants to use node B's graph, node A will be the root and node B will be this node."
                },
                {
                  "key": "bridge",
                  "value": "_predicate_bridge-of",
                  "disabled": false,
                  "description": "This parameter represents the bridge predicate to be used in the current operation. A bridge predicate is neither a functional nor a section predicate, it allows skipping the connected node and land on the next functional or section node. Here is an example:\n- _predicate_bridge-of: The target node will be skipped and ignored."
                },
                {
                  "key": "direction",
                  "value": "true",
                  "disabled": false,
                  "description": "This parameter determines the direction of relationships for the provided predicate: true indicates that children point to the parent, false indicates that the parent points to the children. By default this parameter assumes many to one relationships, true. *Note that the direction should be consistent with all predicates used in the graph."
                },
                {
                  "key": "save",
                  "value": "false",
                  "disabled": false,
                  "description": "If set, the edges will be created, updated or deleted; if not set, the service will only return information on potential operations."
                },
                {
                  "key": "inserted",
                  "value": "true",
                  "disabled": false,
                  "description": "If set, the the service will return the list of inserted edges, if not set, the service will only return operation statistics."
                },
                {
                  "key": "updated",
                  "value": "true",
                  "disabled": false,
                  "description": "If set, the the service will return the list of updated edges, if not set, the service will only return operation statistics."
                },
                {
                  "key": "existing",
                  "value": "true",
                  "disabled": false,
                  "description": "If set, the the service will return the list of existing edges, if not set, the service will only return operation statistics."
                }
              ],
              "protocol": null,
              "host": [
                "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/graph/set/bridge"
              ],
              "port": null,
              "path": null
            },
            "description": "*In order to use this service, the current user must have the `dict` role*.\n\nGraphs are networks of nodes connected to each other by edges. An edge is uniquely identified by its subject-predicate-object relationship. This means that many paths can traverse the same edge: these paths are identified by the graph root node, and the functional predicate characterising its path.\n\nPredicates are of three types: functional, container and bridge. Functional predicates determine what the current graph represents: a controlled vocabulary, a data structure type, etc. Nodes connected with such predicates are valid choices for that predicate. Container predicates are used to group child nodes under a common category that has no function, other\nthan to collect a set of choices. Bridge predicates are used to allow another graph (different root) to share the structure of the current graph. Edges also feature an object property that holds data that can be used during traversals.\n\nThis service can be used to create an edge with bridge predicate. The service expects the root node that will traverse the bridged root graph and the bridge predicate. The custom edge data is provided in the request body.\n\nThe body should contain the custom data relating to the current edge. It can take the following values:\n\n- `object`: This represents valid data for the edge, the provided object will be merged with the existing one. If you set a provided property value to null, if the property exists in the edge data, the service will delete that property from the existing data. If you want to ignore the value, pass an empty object.\n- `null`: If you provide this value the whole custom data container will be reset to an empty object.\n\nIf the edge does not exist, the provided data will be set in the edge, except for the properties that have a null value. If the edge exists, the parameters of the provided data will replace eventual existing matching parameters, or will be erased, if the value is null.\n\nThe service will do the following:\n\n- If the subject-predicate-object combination does not exist, it will create an edge with the bridged and the root nodes, with the provided bridge predicate as the predicate. If custom data was provided, it will be set, or an empty object will be set.\n- If the subject-predicate-object combination exists, it will update the custom data.\n\nIf the service is successful, [`200`], it will return an object containign the following properties:\n\n  - `stats`:\n    - `inserted`: The number of inserted edges.\n    - `updated`: The number of updated edges.\n    - `existing`: The number of ignored existing edges.\n  - `inserted`: The list of inserted edges, if the inserted parameter was set.\n  - `updated`: The list of updated edger, if the updated \\ parameter was set.\n  - `existing`: The list of existing edges, if the existing parameter was set.\n\n\nIf the operation does not succeed, the service will return:\n\n- `400`: **Invalid reference**: the service will return this code if any provided term reference is invalid.\n- `401`: **No current user**: the service will return this code if no user is currently logged in.\n- `403`: **Unauthorised user**: the service will return this code if the current user is not an administrator.\n- `500`: For other types of error.",
            "header": [],
            "body": {
              "mode": "raw",
              "disabled": false,
              "raw": "{\n  \"_name\": \"This is custom data.\"\n}"
            },
            "auth": null
          },
          "protocolProfileBehavior": {
            "followRedirects": false,
            "followOriginalHttpMethod": false,
            "followAuthorizationHeader": false
          },
          "response": []
        },
        {
          "name": "Delete bridge",
          "request": {
            "method": "POST",
            "url": {
              "raw": "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/graph/del/bridge?root=terms/iso_639_2&bridged=terms/iso_639_2_srr&bridge=_predicate_bridge-of&predicate=_predicate_enum-of&direction=true&save=false&prune=true&deleted=true&updated=true&ignored=true",
              "query": [
                {
                  "key": "root",
                  "value": "terms/iso_639_2",
                  "disabled": false,
                  "description": "This parameter represents the document handle of the graph root node. The root, along with the functional predicate, identifies the path that traverses the current edge."
                },
                {
                  "key": "bridged",
                  "value": "terms/iso_639_2_srr",
                  "disabled": false,
                  "description": "This parameter represents the document handle of the node that will become the bridge for the root node. If node A wants to use node B's graph, node A will be the root and node B will be this node."
                },
                {
                  "key": "bridge",
                  "value": "_predicate_bridge-of",
                  "disabled": false,
                  "description": "This parameter represents the bridge predicate to be used in the current operation. A bridge predicate is neither a functional nor a section predicate, it allows skipping the connected node and land on the next functional or section node. Here is an example:\n- _predicate_bridge-of: The target node will be skipped and ignored."
                },
                {
                  "key": "predicate",
                  "value": "_predicate_enum-of",
                  "disabled": false,
                  "description": "This parameter represents the functional predicate of the current edge. A functional predicate determines what function the child node has. Here are a couple of examples:\n- _predicate_enum-of: Valid enumeration element.\n- _predicate_field-of: Valid field element.\n- _predicate_property-of: Valid property element."
                },
                {
                  "key": "direction",
                  "value": "true",
                  "disabled": false,
                  "description": "This parameter determines the direction of relationships for the provided predicate: true indicates that children point to the parent, false indicates that the parent points to the children. By default this parameter assumes many to one relationships, true. *Note that the direction should be consistent with all predicates used in the graph."
                },
                {
                  "key": "save",
                  "value": "false",
                  "disabled": false,
                  "description": "If set, the edges will be created, updated or deleted; if not set, the service will only return information on potential operations."
                },
                {
                  "key": "prune",
                  "value": "true",
                  "disabled": false,
                  "description": "This parameter is used when deleting edges: if set, after deleting the edges connecting parent to chindren, all edges from children to leaf nodes will also be deleted, preventing dangling relationships; if not set, branches originating from child nodes will be left intact, which can be useful if you want to attach the children to another parent."
                },
                {
                  "key": "deleted",
                  "value": "true",
                  "disabled": false,
                  "description": "If set, the the service will return the list of deleted edges, if not set, the service will only return operation statistics."
                },
                {
                  "key": "updated",
                  "value": "true",
                  "disabled": false,
                  "description": "If set, the the service will return the list of updated edges, if not set, the service will only return operation statistics."
                },
                {
                  "key": "ignored",
                  "value": "true",
                  "disabled": false,
                  "description": "If set, the the service will return the list of ignored edges, if not set, the service will only return operation statistics."
                }
              ],
              "protocol": null,
              "host": [
                "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/graph/del/bridge"
              ],
              "port": null,
              "path": null
            },
            "description": "*In order to use this service, the current user must have the `dict` role*.\n\nGraphs are networks of nodes connected to each other by edges. An edge is uniquely identified by its subject-predicate-object relationship. This means that many paths can traverse the same edge: these paths are identified by the graph root node, and the functional predicate characterising its path.\n\nPredicates are of three types: functional, container and bridge. Functional predicates determine what the current graph represents: a controlled vocabulary, a data structure type, etc. Nodes connected with such predicates are valid choices for that predicate. Container predicates are used to group child nodes under a common category that has no function, other\nthan to collect a set of choices. Bridge predicates are used to allow another graph (different root) to share the structure of the current graph. Edges also feature an object property that holds data that can be used during traversals.\n\nThis service can be used to delete an edge with bridge predicate. The service expects the root node that will traverse the bridged root graph and the bridge predicate. The custom edge data is provided in the request body. The service also expects the functional predicate, that will be traversed if the prune flag was set, to delete leaf branches.\n\nThe body contains two properties:\n\n- `sections`: Graphs have predicates that indicate the type of graph: enumeration, field, etc. There are other predicates, however, whose goal is to link nodes which will not have the function of the main predicate. The provided default values indicate sections, that represent display or category nodes used for subdividing child nodes, and bridges, which allow one node to connect to another node through a bridge node.\n- `data`: An object containing the custom data for the current edge.\n\nThe body data property take the following values:\n\n- `object`: This represents valid data for the edge, the provided object will be merged with the existing one. If you set a provided property value to null, if the property exists in the edge data, the service will delete that property from the existing data. If you want to ignore the value, pass an empty object.\n- `null`: If you provide this value the whole custom data container will be reset to an empty object.\n\nThe service will do the following:\n\n- If the subject-predicate-object combination exists, it will delete the edge.\n    - If the prune flag is set, the service will delete all instances of the root in all paths featuring the provided predicate.\n\nIf the service is successful, [`200`], it will return an object containign the following properties:\n\n  - `stats`:\n    - `inserted`: The number of inserted edges.\n    - `updated`: The number of updated edges.\n    - `existing`: The number of ignored existing edges.\n  - `inserted`: The list of inserted edges, if the inserted parameter was set.\n  - `updated`: The list of updated edger, if the updated \\ parameter was set.\n  - `existing`: The list of existing edges, if the existing parameter was set.\n\n\nIf the operation does not succeed, the service will return:\n\n- `400`: **Invalid reference**: the service will return this code if any provided term reference is invalid.\n- `401`: **No current user**: the service will return this code if no user is currently logged in.\n- `403`: **Unauthorised user**: the service will return this code if the current user is not an administrator.\n- `500`: For other types of error.",
            "header": [],
            "body": {
              "mode": "raw",
              "disabled": false,
              "raw": "{\n  \"sections\": [\n    \"_predicate_section-of\",\n    \"_predicate_bridge-of\"\n  ],\n  \"data\": {\"_name\": \"Custom data.\"}\n}"
            },
            "auth": null
          },
          "protocolProfileBehavior": {
            "followRedirects": false,
            "followOriginalHttpMethod": false,
            "followAuthorizationHeader": false
          },
          "response": []
        },
        {
          "name": "Set links",
          "request": {
            "method": "POST",
            "url": {
              "raw": "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/graph/set/link?parent=terms/chr_LeafAreaIndex&predicate=_predicate_requires_indicator&direction=false&descriptors=true&save=false&inserted=true&updated=true&existing=true",
              "query": [
                {
                  "key": "parent",
                  "value": "terms/chr_LeafAreaIndex",
                  "disabled": false,
                  "description": "This parameter represents the document handle of the node that represents the parent to which the child nodes point to, or that points to the child nodes."
                },
                {
                  "key": "predicate",
                  "value": "_predicate_requires_indicator",
                  "disabled": false,
                  "description": "This parameter represents the predicate of the current link. Here are a couple of examples:\n- _predicate_requires_indicator: Required indicator predicate.\n- _predicate_requires_metadata: Required metadata indicator predicate."
                },
                {
                  "key": "direction",
                  "value": "false",
                  "disabled": false,
                  "description": "This parameter determines the direction of relationships for the provided predicate: true indicates that children point to the parent, false indicates that the parent points to the children. By default this parameter assumes many to one relationships, true. *Note that the direction should be consistent with all predicates used in the graph."
                },
                {
                  "key": "descriptors",
                  "value": "true",
                  "disabled": false,
                  "description": "This parameter determines whether all link nodes must be descriptors: true indicates that parent and children must be descriptors; false indicates that parent and children need not be descriptors"
                },
                {
                  "key": "save",
                  "value": "false",
                  "disabled": false,
                  "description": "If set, the edges will be created, updated or deleted; if not set, the service will only return information on potential operations."
                },
                {
                  "key": "inserted",
                  "value": "true",
                  "disabled": false,
                  "description": "If set, the the service will return the list of inserted edges, if not set, the service will only return operation statistics."
                },
                {
                  "key": "updated",
                  "value": "true",
                  "disabled": false,
                  "description": "If set, the the service will return the list of updated edges, if not set, the service will only return operation statistics."
                },
                {
                  "key": "existing",
                  "value": "true",
                  "disabled": false,
                  "description": "If set, the the service will return the list of existing edges, if not set, the service will only return operation statistics."
                }
              ],
              "protocol": null,
              "host": [
                "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/graph/set/link"
              ],
              "port": null,
              "path": null
            },
            "description": "*In order to use this service, the current user must have the `dict` role*.\n\nLinks are one-level graphs in which nodes are connected with subject-predicate-object links that contain a custom data record. Unlike edges, only one link can exist and there is no root or path concept. Linked items are either linked or unlinked, or their custom data updated.\n\nThis service allows creating new links, or updating the custom data of an existing link. The service expects the parent node, the link predicate, the direction of the predicate, a flag indicating whether all nodes must be descriptors, and a set of other flags governing the operation. The service will return the number of inserted, modified or ignored links.\n\nThe request body should hold an object containing the following elements:\n\n- `children`: A key/value dictionary in which the key represents the child node document handle, which represents the linked node, and the value represents custom data associated with the corresponding link.\n\nIf the service is successful, [`200`], it will return an object containign the following properties:\n\n  - `stats`:\n    - `inserted`: The number of inserted edges.\n    - `updated`: The number of updated edges.\n    - `existing`: The number of ignored existing edges.\n  - `inserted`: The list of inserted edges, if the inserted parameter was set.\n  - `updated`: The list of updated edger, if the updated \\ parameter was set.\n  - `existing`: The list of existing edges, if the existing parameter was set.\n\n\nIf the operation does not succeed, the service will return:\n\n- `400`: **Invalid reference**: the service will return this code if any provided term reference is invalid.\n- `401`: **No current user**: the service will return this code if no user is currently logged in.\n- `403`: **Unauthorised user**: the service will return this code if the current user is not an administrator.\n- `500`: For other types of error.",
            "header": [],
            "body": {
              "mode": "raw",
              "disabled": false,
              "raw": "{\n  \"children\": {\n    \"terms/std_date\": {\"_name\": \"Custom data.\"}\n  }\n}"
            },
            "auth": null
          },
          "protocolProfileBehavior": {
            "followRedirects": false,
            "followOriginalHttpMethod": false,
            "followAuthorizationHeader": false
          },
          "response": []
        },
        {
          "name": "Delete links",
          "request": {
            "method": "POST",
            "url": {
              "raw": "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/graph/del/link?parent=terms/chr_LeafAreaIndex&predicate=_predicate_requires_indicator&direction=false&save=false&deleted=true&ignored=true",
              "query": [
                {
                  "key": "parent",
                  "value": "terms/chr_LeafAreaIndex",
                  "disabled": false,
                  "description": "This parameter represents the document handle of the node that represents the parent to which the child nodes point to, or that points to the child nodes."
                },
                {
                  "key": "predicate",
                  "value": "_predicate_requires_indicator",
                  "disabled": false,
                  "description": "This parameter represents the predicate of the current link. Here are a couple of examples:\n- _predicate_requires_indicator: Required indicator predicate.\n- _predicate_requires_metadata: Required metadata indicator predicate."
                },
                {
                  "key": "direction",
                  "value": "false",
                  "disabled": false,
                  "description": "This parameter determines the direction of relationships for the provided predicate: true indicates that children point to the parent, false indicates that the parent points to the children. By default this parameter assumes many to one relationships, true. *Note that the direction should be consistent with all predicates used in the graph."
                },
                {
                  "key": "save",
                  "value": "false",
                  "disabled": false,
                  "description": "If set, the edges will be created, updated or deleted; if not set, the service will only return information on potential operations."
                },
                {
                  "key": "deleted",
                  "value": "true",
                  "disabled": false,
                  "description": "If set, the the service will return the list of deleted edges, if not set, the service will only return operation statistics."
                },
                {
                  "key": "ignored",
                  "value": "true",
                  "disabled": false,
                  "description": "If set, the the service will return the list of ignored edges, if not set, the service will only return operation statistics."
                }
              ],
              "protocol": null,
              "host": [
                "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/graph/del/link"
              ],
              "port": null,
              "path": null
            },
            "description": "*In order to use this service, the current user must have the `dict` role*.\n\nLinks are one-level graphs in which nodes are connected with subject-predicate-object links that contain a custom data record. Unlike edges, only one link can exist and there is no root or path concept. Linked items are eikther linked or unlinked, or their custom data updated.\n\nThis service will delete a link between two nodes The service expects the parent node, the link predicate, the direction of the predicate, a flag indicating whether all nodes must be descriptors, and a set of other flags governing the operation. The service will return the number of inserted, modified or ignored links.\n\nThe request body is an array containing the child node document handles. If a link exists between the parent, the current child and the predicate, the service will delete the link.\n\nIf the service is successful, [`200`], it will return an object containign the following properties:\n\n  - `stats`:\n    - `deleted`: The number of deleted edges.\n    - `ignored`: The number of ignored edges.\n  - `deleted`: The list of deleted edges, if the deleted parameter was set.\n  - `ignored`: The list of ignored edges, if the ignored parameter was set.\n\n\nIf the operation does not succeed, the service will return:\n\n- `400`: **Invalid reference**: the service will return this code if any provided term reference is invalid.\n- `401`: **No current user**: the service will return this code if no user is currently logged in.\n- `403`: **Unauthorised user**: the service will return this code if the current user is not an administrator.\n- `500`: For other types of error.",
            "header": [],
            "body": {
              "mode": "raw",
              "disabled": false,
              "raw": "[\n   \"terms/std_date\",\n   \"terms/_type\"\n]"
            },
            "auth": null
          },
          "protocolProfileBehavior": {
            "followRedirects": false,
            "followOriginalHttpMethod": false,
            "followAuthorizationHeader": false
          },
          "response": []
        }
      ],
      "protocolProfileBehavior": null,
      "response": []
    },
    {
      "name": "EDGE GRAPHS",
      "item": [
        {
          "name": "Flat list of functional document handles",
          "request": {
            "method": "GET",
            "url": {
              "raw": "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/edge/all/handles?root=terms/_type&predicate=_predicate_enum-of&direction=true",
              "query": [
                {
                  "key": "root",
                  "value": "terms/_type",
                  "disabled": false,
                  "description": "This parameter represents the document handle of the graph root node. The root, along with the functional predicate, identifies the path that traverses the current edge."
                },
                {
                  "key": "predicate",
                  "value": "_predicate_enum-of",
                  "disabled": false,
                  "description": "This parameter represents the functional predicate of the current edge. A functional predicate determines what function the child node has. Here are a couple of examples:\n- _predicate_enum-of: Valid enumeration element.\n- _predicate_field-of: Valid field element.\n- _predicate_property-of: Valid property element."
                },
                {
                  "key": "direction",
                  "value": "true",
                  "disabled": false,
                  "description": "This parameter determines the direction of relationships for the provided predicate: true indicates that the relationship direction starts from the leaf nodes and points to the root node, this represents a many-to-one relationship; false indicates that the relationship direction starts from the graph root and points to the leaf nodes, this represents a one-to-many relationship. By default this parameter assumes many-to-one relationships, true.\nNote that the direction should be consistent with all predicates used in the graph."
                }
              ],
              "protocol": null,
              "host": [
                "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/edge/all/handles"
              ],
              "port": null,
              "path": null
            },
            "description": "Use this service to get the flattened list of functional node document handles.\n\n*In order to use this service, the current user must have the `read` role*.\n\nThis service can be used to retrieve the *flattened list* of *node document handles*, belonging to the *graph identified by the provided root node document handle*, that are *connected* by the *provided functional predicate*.\n\n*Note: this service will return all the functional nodes of the graph, this means that large graphs may block the service, so use this service with caution.*\n\nThe service expects the document handle of the graph root node, the functional predicate of the graph and the direction of the graph relationships.\n\nIf the service is successful, [`200`], it will return an array of document handles representing the graph nodes connected with the provided functional predicate.\n\nNote that no hierarchy or order is maintained, it is a flat list of document handles from indeterminate depth levels.\n\nIf the operation does not succeed, the service will return:\n\n- `401`: **No current user**: the service will return this code if no user is currently logged in.\n- `403`: **Unauthorised user**: the service will return this code if the current user is not an administrator.\n- `500`: For other types of error.",
            "header": [],
            "body": null,
            "auth": null
          },
          "protocolProfileBehavior": {
            "followRedirects": false,
            "followOriginalHttpMethod": false,
            "followAuthorizationHeader": false
          },
          "response": []
        },
        {
          "name": "Flat list of functional document records",
          "request": {
            "method": "GET",
            "url": {
              "raw": "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/edge/all/docs?root=terms/_type&predicate=_predicate_enum-of&direction=true",
              "query": [
                {
                  "key": "root",
                  "value": "terms/_type",
                  "disabled": false,
                  "description": "This parameter represents the document handle of the graph root node. The root, along with the functional predicate, identifies the path that traverses the current edge."
                },
                {
                  "key": "predicate",
                  "value": "_predicate_enum-of",
                  "disabled": false,
                  "description": "This parameter represents the functional predicate of the current edge. A functional predicate determines what function the child node has. Here are a couple of examples:\n- _predicate_enum-of: Valid enumeration element.\n- _predicate_field-of: Valid field element.\n- _predicate_property-of: Valid property element."
                },
                {
                  "key": "direction",
                  "value": "true",
                  "disabled": false,
                  "description": "This parameter determines the direction of relationships for the provided predicate: true indicates that the relationship direction starts from the leaf nodes and points to the root node, this represents a many-to-one relationship; false indicates that the relationship direction starts from the graph root and points to the leaf nodes, this represents a one-to-many relationship. By default this parameter assumes many-to-one relationships, true.\n*Note that the direction should be consistent with all predicates used in the graph."
                }
              ],
              "protocol": null,
              "host": [
                "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/edge/all/docs"
              ],
              "port": null,
              "path": null
            },
            "description": "Use this service to get the flattened list of functional node document records.\n\n*In order to use this service, the current user must have the `read` role*.\n\nThis service can be used to retrieve the *flattened list* of *node document records*, belonging to the *graph identified by the provided root node document handle*, that are *connected* by the *provided functional predicate*.\n\n*Note: this service will return all the functional nodes of the graph, this means that large graphs may block the service, so use this service with caution.*\n\nThe service expects the document handle of the graph root node, the functional predicate of the graph and the direction of the graph relationships.\n\nIf the service is successful, [`200`], it will return an array of document records representing the graph nodes connected with the provided functional predicate.\n\nNote that no hierarchy or order is maintained, it is a flat list of records from indeterminate depth levels.\n\nIf the operation does not succeed, the service will return:\n\n- `401`: **No current user**: the service will return this code if no user is currently logged in.\n- `403`: **Unauthorised user**: the service will return this code if the current user is not an administrator.\n- `500`: For other types of error.",
            "header": [],
            "body": null,
            "auth": null
          },
          "protocolProfileBehavior": {
            "followRedirects": false,
            "followOriginalHttpMethod": false,
            "followAuthorizationHeader": false
          },
          "response": []
        },
        {
          "name": "Flat list of functional edges",
          "request": {
            "method": "GET",
            "url": {
              "raw": "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/edge/all/edges?root=terms/_type&predicate=_predicate_enum-of&direction=true",
              "query": [
                {
                  "key": "root",
                  "value": "terms/_type",
                  "disabled": false,
                  "description": "This parameter represents the document handle of the graph root node. The root, along with the functional predicate, identifies the path that traverses the current edge."
                },
                {
                  "key": "predicate",
                  "value": "_predicate_enum-of",
                  "disabled": false,
                  "description": "This parameter represents the functional predicate of the current edge. A functional predicate determines what function the child node has. Here are a couple of examples:\n- _predicate_enum-of: Valid enumeration element.\n- _predicate_field-of: Valid field element.\n- _predicate_property-of: Valid property element."
                },
                {
                  "key": "direction",
                  "value": "true",
                  "disabled": false,
                  "description": "This parameter determines the direction of relationships for the provided predicate: true indicates that the relationship direction starts from the leaf nodes and points to the root node, this represents a many-to-one relationship; false indicates that the relationship direction starts from the graph root and points to the leaf nodes, this represents a one-to-many relationship. By default this parameter assumes many-to-one relationships, true.\n*Note that the direction should be consistent with all predicates used in the graph."
                }
              ],
              "protocol": null,
              "host": [
                "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/edge/all/edges"
              ],
              "port": null,
              "path": null
            },
            "description": "Use this service to get the flattened list of functional edge records.\n\n*In order to use this service, the current user must have the `read` role*.\n\nThis service can be used to retrieve the *flattened list* of *edge records*, belonging to the *graph identified by the provided root node document handle*, that are *connected* by the *provided functional predicate*.\n\n*Note: this service will return all the edges of the graph, this means that large graphs may block the service, so use this service with caution.*\n\nThe service expects the document handle of the graph root node, the functional predicate of the graph and the direction of the graph relationships.\n\nIf the service is successful, [`200`], it will return an array of edge records from the graph identified by the root node that use the provided predicate.\n\nNote that no hierarchy or order is maintained, it is a flat list of records from indeterminate depth levels.\n\nIf the operation does not succeed, the service will return:\n\n- `401`: **No current user**: the service will return this code if no user is currently logged in.\n- `403`: **Unauthorised user**: the service will return this code if the current user is not an administrator.\n- `500`: For other types of error.",
            "header": [],
            "body": null,
            "auth": null
          },
          "protocolProfileBehavior": {
            "followRedirects": false,
            "followOriginalHttpMethod": false,
            "followAuthorizationHeader": false
          },
          "response": []
        },
        {
          "name": "Flat list of graph relationships",
          "request": {
            "method": "POST",
            "url": {
              "raw": "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/edge/tree/handles?root=terms/_predicate&predicate=_predicate_enum-of&direction=true&levels=10",
              "query": [
                {
                  "key": "root",
                  "value": "terms/_predicate",
                  "disabled": false,
                  "description": "This parameter represents the document handle of the graph root node. The root, along with the functional predicate, identifies the path that traverses the current edge."
                },
                {
                  "key": "predicate",
                  "value": "_predicate_enum-of",
                  "disabled": false,
                  "description": "This parameter represents the functional predicate of the current edge. A functional predicate determines what function the child node has. Here are a couple of examples:\n- _predicate_enum-of: Valid enumeration element.\n- _predicate_field-of: Valid field element.\n- _predicate_property-of: Valid property element."
                },
                {
                  "key": "direction",
                  "value": "true",
                  "disabled": false,
                  "description": "This parameter determines the direction of relationships for the provided predicate: true indicates that the relationship direction starts from the leaf nodes and points to the root node, this represents a many-to-one relationship; false indicates that the relationship direction starts from the graph root and points to the leaf nodes, this represents a one-to-many relationship. By default this parameter assumes many-to-one relationships, true.\n*Note that the direction should be consistent with all predicates used in the graph."
                },
                {
                  "key": "levels",
                  "value": "10",
                  "disabled": false,
                  "description": "Maximum tree depth level for traversal."
                }
              ],
              "protocol": null,
              "host": [
                "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/edge/tree/handles"
              ],
              "port": null,
              "path": null
            },
            "description": "Use this service to get a list of records containing all relationship groups expressed as document handles.\n\n*In order to use this service, the current user must have the `read` role*.\n\nThe service expects the graph root node document handle, the functional predicate of the graph, the direction of the relationships and the maximum number of depth levels to traverse. The request body should contain the list of non-functional predicates to consider while traversing the graph, by default it contains the default section and bridge predicates.\n\nIf the service is successful, [`200`], it will return an *array* of *subject-predicate-object* groups featuring the parent node handle, the predicate and the list of related nodes as document handles. Each group is structured as follows:\n\n- `<one>`: The property name is the document handle of the *one* part of the *one-to-many* or *many-to-one* related nodes.\n    - `<predicate>`: The property name is the predicate that connects the nodes.\n      - `<array>`: The value of the above predicate property is an array containing the list of nodes connected by the predicate, representing the *many* part of the *one-to-many* or *many-to-one* related nodes.\n\nTo rebuild the nested tree you should take the element whose root property corresponds to the provided `root` parameter, then recursively iterate each child member matching the elements of the returned list.\n\nIf the operation does not succeed, the service will return:\n\n- `401`: **No current user**: the service will return this code if no user is currently logged in.\n- `403`: **Unauthorised user**: the service will return this code if the current user is not an administrator.\n- `500`: For other types of error.",
            "header": [],
            "body": {
              "mode": "raw",
              "disabled": false,
              "raw": "[\n  \"_predicate_section-of\",\n  \"_predicate_bridge-of\"\n]"
            },
            "auth": null
          },
          "protocolProfileBehavior": {
            "followRedirects": false,
            "followOriginalHttpMethod": false,
            "followAuthorizationHeader": false
          },
          "response": []
        },
        {
          "name": "Match preferred node by document handle",
          "request": {
            "method": "POST",
            "url": {
              "raw": "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/edge/match/node?root=terms/iso_639_1&target=terms/iso_639_1_it&predicate=_predicate_enum-of&direction=true&levels=10",
              "query": [
                {
                  "key": "root",
                  "value": "terms/iso_639_1",
                  "disabled": false,
                  "description": "This parameter represents the document handle of the graph root node. The root, along with the functional predicate, identifies the path that traverses the current edge."
                },
                {
                  "key": "target",
                  "value": "terms/iso_639_1_it",
                  "disabled": false,
                  "description": "This parameter represents the document handle of the node that represents the target of the graph traversal"
                },
                {
                  "key": "predicate",
                  "value": "_predicate_enum-of",
                  "disabled": false,
                  "description": "This parameter represents the functional predicate of the current edge. A functional predicate determines what function the child node has. Here are a couple of examples:\n- _predicate_enum-of: Valid enumeration element.\n- _predicate_field-of: Valid field element.\n- _predicate_property-of: Valid property element."
                },
                {
                  "key": "direction",
                  "value": "true",
                  "disabled": false,
                  "description": "This parameter determines the direction of relationships for the provided predicate: true indicates that the relationship direction starts from the leaf nodes and points to the root node, this represents a many-to-one relationship; false indicates that the relationship direction starts from the graph root and points to the leaf nodes, this represents a one-to-many relationship. By default this parameter assumes many-to-one relationships, true.\n*Note that the direction should be consistent with all predicates used in the graph."
                },
                {
                  "key": "levels",
                  "value": "10",
                  "disabled": false,
                  "description": "Maximum depth level for traversals when node is not functional."
                }
              ],
              "protocol": null,
              "host": [
                "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/edge/match/node"
              ],
              "port": null,
              "path": null
            },
            "description": "Use this service to get the *preferred node record* corresponding to the provided *node document handle*.\n\n*In order to use this service, the current user must have the `read` role*.\n\nThe service expects the graph root node document handle, the document handle of the target node, the functional predicate of the graph, the direction of the relationships and the maximum number of levels to traverse when looking for the preferred node. The request body should contain the list of non-functional predicates to consider while traversing the graph, by default it contains the default section and bridge predicates.\n\nThe service will first locate the edge containing the target node: if found, it will check whether the target node is related by the functional predicate, or not. If the node is related by the provided predicate the search is over. If that is not the case, it means that the target node is not a valid choice for the graph: the service will traverse the graph starting from the target node until it finds a node related by the provided functional predicate, that will be the preferred node.\n\nIf the service is successful, [`200`], it will return the preferred node record, which can be the provided target node, or another node. The service will return an empty object if there was no match.\n\nIf the operation does not succeed, the service will return:\n\n- `401`: **No current user**: the service will return this code if no user is currently logged in.\n- `403`: **Unauthorised user**: the service will return this code if the current user is not an administrator.\n- `500`: For other types of error.\n\n**Note that this service will honour preferred enumerations, this means that if a term is matched that has a preferred alternative, the latter will be returned, regardless if the preferred term does not belong to the provided path**.",
            "header": [],
            "body": {
              "mode": "raw",
              "disabled": false,
              "raw": "[\n  \"_predicate_section-of\",\n  \"_predicate_bridge-of\"\n]"
            },
            "auth": null
          },
          "protocolProfileBehavior": {
            "followRedirects": false,
            "followOriginalHttpMethod": false,
            "followAuthorizationHeader": false
          },
          "response": []
        },
        {
          "name": "Match preferred node by code",
          "request": {
            "method": "POST",
            "url": {
              "raw": "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/edge/match/code?root=terms/iso_639_1&code=it&field=_lid&predicate=_predicate_enum-of&direction=true&levels=10",
              "query": [
                {
                  "key": "root",
                  "value": "terms/iso_639_1",
                  "disabled": false,
                  "description": "This parameter represents the document handle of the graph root node. The root, along with the functional predicate, identifies the path that traverses the current edge."
                },
                {
                  "key": "code",
                  "value": "it",
                  "disabled": false,
                  "description": "Target code to be matched."
                },
                {
                  "key": "field",
                  "value": "_lid",
                  "disabled": false,
                  "description": "Code section field name where the code should be matched:\n_lid: Local identifier. Match the local identifier code.\n_gid: Global identifier. Match the global identifier code.\n_aid: List of official codes. Match the official code.\n_pid: List of provider codes. Match the provided code.\n_nid: Namespace. Match the namespace code."
                },
                {
                  "key": "predicate",
                  "value": "_predicate_enum-of",
                  "disabled": false,
                  "description": "This parameter represents the functional predicate of the current edge. A functional predicate determines what function the child node has. Here are a couple of examples:\n- _predicate_enum-of: Valid enumeration element.\n- _predicate_field-of: Valid field element.\n- _predicate_property-of: Valid property element."
                },
                {
                  "key": "direction",
                  "value": "true",
                  "disabled": false,
                  "description": "This parameter determines the direction of relationships for the provided predicate: true indicates that the relationship direction starts from the leaf nodes and points to the root node, this represents a many-to-one relationship; false indicates that the relationship direction starts from the graph root and points to the leaf nodes, this represents a one-to-many relationship. By default this parameter assumes many-to-one relationships, true.\n*Note that the direction should be consistent with all predicates used in the graph."
                },
                {
                  "key": "levels",
                  "value": "10",
                  "disabled": false,
                  "description": "Maximum depth level for traversals when node is not functional."
                }
              ],
              "protocol": null,
              "host": [
                "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/edge/match/code"
              ],
              "port": null,
              "path": null
            },
            "description": "Use this service to get the *preferred node record* corresponding to the provided *node code*.\n\n*In order to use this service, the current user must have the `read` role*.\n\nThe service expects the graph root node document handle, the code to be matched, the term codes section field in which to match the code, the functional predicate of the graph, the direction of the relationships and the maximum number of levels to traverse when looking for the preferred node. The request body should contain the list of non-functional predicates to consider while traversing the graph, by default it contains the default section and bridge predicates.\n\n*Codes are searched by default in the terms collection documents.*\n\nThe service will first search for all terms that feature the provided code in the provided field. Then the service will filter the found terms by selecting only those matching the subject or object fields of the edge, depending on the relationships direction, and selecting only those edges that belong to the graph identified by the provided root node handle. If the matched node is related by the provided predicate the search is over. If that is not the case, the service will traverse the graph starting from the target node until it finds a node related by the provided functional predicate, that will be the preferred node.\n\nIf the service is successful, [`200`], it will return the list of preferred node records, which can be the terms matched by the provided code, or other nodes. The service will return an empty array if there was no match.\n\nIf the operation does not succeed, the service will return:\n\n- `401`: **No current user**: the service will return this code if no user is currently logged in.\n- `403`: **Unauthorised user**: the service will return this code if the current user is not an administrator.\n- `500`: For other types of error.\n\n**Note that this service will honour preferred enumerations, this means that if a term is matched that has a preferred alternative, the latter will be returned, regardless if the preferred term does not belong to the provided path**.",
            "header": [],
            "body": {
              "mode": "raw",
              "disabled": false,
              "raw": "[\n  \"_predicate_section-of\",\n  \"_predicate_bridge-of\"\n]"
            },
            "auth": null
          },
          "protocolProfileBehavior": {
            "followRedirects": false,
            "followOriginalHttpMethod": false,
            "followAuthorizationHeader": false
          },
          "response": []
        },
        {
          "name": "Traverse graph levels",
          "request": {
            "method": "POST",
            "url": {
              "raw": "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/edge/path/levels?root=terms/_type&parent=terms/_type_string&predicate=_predicate_enum-of&direction=true&min_level=0&max_level=10",
              "query": [
                {
                  "key": "root",
                  "value": "terms/_type",
                  "disabled": false,
                  "description": "This parameter represents the document handle of the graph root node. The root, along with the functional predicate, identifies the path that traverses the current edge."
                },
                {
                  "key": "parent",
                  "value": "terms/_type_string",
                  "disabled": false,
                  "description": "This parameter represents the document handle of the starting node for the traversal."
                },
                {
                  "key": "predicate",
                  "value": "_predicate_enum-of",
                  "disabled": false,
                  "description": "This parameter represents the functional predicate of the current edge. A functional predicate determines what function the child node has. Here are a couple of examples:\n- _predicate_enum-of: Valid enumeration element.\n- _predicate_field-of: Valid field element.\n- _predicate_property-of: Valid property element."
                },
                {
                  "key": "direction",
                  "value": "true",
                  "disabled": false,
                  "description": "This parameter determines the direction of relationships for the provided predicate: true indicates that the relationship direction starts from the leaf nodes and points to the root node, this represents a many-to-one relationship; false indicates that the relationship direction starts from the graph root and points to the leaf nodes, this represents a one-to-many relationship. By default this parameter assumes many-to-one relationships, true.\n*Note that the direction should be consistent with all predicates used in the graph."
                },
                {
                  "key": "min_level",
                  "value": "0",
                  "disabled": false,
                  "description": "Starting depth level of traversal."
                },
                {
                  "key": "max_level",
                  "value": "10",
                  "disabled": false,
                  "description": "Maximum depth level for traversals when node is not functional."
                }
              ],
              "protocol": null,
              "host": [
                "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/edge/path/levels"
              ],
              "port": null,
              "path": null
            },
            "description": "Use this service to *traverse a graph* starting from a *specific node* and *depth level*, until a *maximum level* has been reached.\n\n*In order to use this service, the current user must have the `read` role*.\n\nThe service expects the graph root node document handle, the document handle of the traversal starting node, the functional predicate of the graph, the direction of the relationships, the starting depth level of the traversal and the maximum number of levels to traverse. The request body should contain the list of non-functional predicates to consider while traversing the graph, by default it contains the default section and bridge predicates.\n\nIf the service is successful, [`200`], it will return the graph paths corresponding to the provided starting and ending depth levels. It will be an array of paths each structured as follows:\n\n- `vertices`: An array of vertex document records corresponding to the traversed nodes.\n- `edges`: An array of edge document records connecting the above nodes.\n\nIf the operation does not succeed, the service will return:\n\n- `401`: **No current user**: the service will return this code if no user is currently logged in.\n- `403`: **Unauthorised user**: the service will return this code if the current user is not an administrator.\n- `500`: For other types of error.\n\n**Note that this service will honour preferred enumerations, this means that if a term is matched that has a preferred alternative, the latter will be returned, regardless if the preferred term does not belong to the provided path**.",
            "header": [],
            "body": {
              "mode": "raw",
              "disabled": false,
              "raw": "[\n  \"_predicate_section-of\",\n  \"_predicate_bridge-of\"\n]"
            },
            "auth": null
          },
          "protocolProfileBehavior": {
            "followRedirects": false,
            "followOriginalHttpMethod": false,
            "followAuthorizationHeader": false
          },
          "response": []
        },
        {
          "name": "Traverse graph to matching node",
          "request": {
            "method": "POST",
            "url": {
              "raw": "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/edge/path/node?root=terms/_predicate&target=terms/iso_3166_2_type_autonomous-republic&predicate=_predicate_enum-of&direction=true&max_level=10",
              "query": [
                {
                  "key": "root",
                  "value": "terms/_predicate",
                  "disabled": false,
                  "description": "This parameter represents the document handle of the graph root node. The root, along with the functional predicate, identifies the path that traverses the current edge."
                },
                {
                  "key": "target",
                  "value": "terms/iso_3166_2_type_autonomous-republic",
                  "disabled": false,
                  "description": "This parameter represents the document handle of the node that represents the target of the graph traversal."
                },
                {
                  "key": "predicate",
                  "value": "_predicate_enum-of",
                  "disabled": false,
                  "description": "This parameter represents the functional predicate of the current edge. A functional predicate determines what function the child node has. Here are a couple of examples:\n- _predicate_enum-of: Valid enumeration element.\n- _predicate_field-of: Valid field element.\n- _predicate_property-of: Valid property element."
                },
                {
                  "key": "direction",
                  "value": "true",
                  "disabled": false,
                  "description": "This parameter determines the direction of relationships for the provided predicate: true indicates that the relationship direction starts from the leaf nodes and points to the root node, this represents a many-to-one relationship; false indicates that the relationship direction starts from the graph root and points to the leaf nodes, this represents a one-to-many relationship. By default this parameter assumes many-to-one relationships, true.\n*Note that the direction should be consistent with all predicates used in the graph."
                },
                {
                  "key": "max_level",
                  "value": "10",
                  "disabled": false,
                  "description": "Maximum depth level for traversals when node is not functional."
                }
              ],
              "protocol": null,
              "host": [
                "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/edge/path/node"
              ],
              "port": null,
              "path": null
            },
            "description": "Use this service to *traverse a graph* starting from the *root node* until a *target node* has been matched.\n\n*In order to use this service, the current user must have the `read` role*.\n\nThe service expects the graph root node document handle, the document handle of the node to match, the functional predicate of the graph, the direction of the relationships and the maximum number of levels to traverse. The request body should contain the list of non-functional predicates to consider while traversing the graph, by default it contains the default section and bridge predicates.\n\nIf the service is successful, [`200`], it will return the path from the graph root node to the matched target node. It will be an array of paths each structured as follows:\n\n- `vertices`: An array of vertex document records corresponding to the traversed nodes.\n- `edges`: An array of edge document records connecting the above nodes.\n\nIf the operation does not succeed, the service will return:\n\n- `401`: **No current user**: the service will return this code if no user is currently logged in.\n- `403`: **Unauthorised user**: the service will return this code if the current user is not an administrator.\n- `500`: For other types of error.\n\n**Note that this service will honour preferred enumerations, this means that if a term is matched that has a preferred alternative, the latter will be returned, regardless if the preferred term does not belong to the provided path**.",
            "header": [],
            "body": {
              "mode": "raw",
              "disabled": false,
              "raw": "[\n  \"_predicate_section-of\",\n  \"_predicate_bridge-of\"\n]"
            },
            "auth": null
          },
          "protocolProfileBehavior": {
            "followRedirects": false,
            "followOriginalHttpMethod": false,
            "followAuthorizationHeader": false
          },
          "response": []
        },
        {
          "name": "Traverse graph to matching code",
          "request": {
            "method": "POST",
            "url": {
              "raw": "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/edge/path/code?root=terms/_predicate&code=autonomous-republic&field=_lid&predicate=_predicate_enum-of&direction=true&max_level=10",
              "query": [
                {
                  "key": "root",
                  "value": "terms/_predicate",
                  "disabled": false,
                  "description": "This parameter represents the document handle of the graph root node. The root, along with the functional predicate, identifies the path that traverses the current edge."
                },
                {
                  "key": "code",
                  "value": "autonomous-republic",
                  "disabled": false,
                  "description": "The code to match in the field."
                },
                {
                  "key": "field",
                  "value": "_lid",
                  "disabled": false,
                  "description": "Code section field name where the code should be matched:\n_lid: Local identifier. Match the local identifier code.\n_gid: Global identifier. Match the global identifier code.\n_aid: List of official codes. Match the official code.\n_pid: List of provider codes. Match the provided code.\n_nid: Namespace. Match the namespace code."
                },
                {
                  "key": "predicate",
                  "value": "_predicate_enum-of",
                  "disabled": false,
                  "description": "This parameter represents the functional predicate of the current edge. A functional predicate determines what function the child node has. Here are a couple of examples:\n- _predicate_enum-of: Valid enumeration element.\n- _predicate_field-of: Valid field element.\n- _predicate_property-of: Valid property element."
                },
                {
                  "key": "direction",
                  "value": "true",
                  "disabled": false,
                  "description": "This parameter determines the direction of relationships for the provided predicate: true indicates that the relationship direction starts from the leaf nodes and points to the root node, this represents a many-to-one relationship; false indicates that the relationship direction starts from the graph root and points to the leaf nodes, this represents a one-to-many relationship. By default this parameter assumes many-to-one relationships, true.\n*Note that the direction should be consistent with all predicates used in the graph."
                },
                {
                  "key": "max_level",
                  "value": "10",
                  "disabled": false,
                  "description": "Maximum depth level for traversals when node is not functional."
                }
              ],
              "protocol": null,
              "host": [
                "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/edge/path/code"
              ],
              "port": null,
              "path": null
            },
            "description": "Use this service to *traverse a graph* starting from the *root node* until a *target node* has been matched *featuring the provided code*.\n\n*In order to use this service, the current user must have the `read` role*.\n\nThe service expects the graph root node document handle, the code to be matched, the term codes section field in which to match the code, the functional predicate of the graph, the direction of the relationships and the maximum number of levels to traverse. The request body should contain the list of non-functional predicates to consider while traversing the graph, by default it contains the default section and bridge predicates.\n\nIf the service is successful, [`200`], it will return the path from the graph root node to the node that matches the provided code in the provided field. It will be an array of paths each structured as follows:\n\n- `vertices`: An array of vertex document records corresponding to the traversed nodes.\n- `edges`: An array of edge document records connecting the above nodes.\n\nIf the operation does not succeed, the service will return:\n\n- `401`: **No current user**: the service will return this code if no user is currently logged in.\n- `403`: **Unauthorised user**: the service will return this code if the current user is not an administrator.\n- `500`: For other types of error.\n\n**Note that this service will honour preferred enumerations, this means that if a term is matched that has a preferred alternative, the latter will be returned, regardless if the preferred term does not belong to the provided path**.",
            "header": [],
            "body": {
              "mode": "raw",
              "disabled": false,
              "raw": "[\n  \"_predicate_section-of\",\n  \"_predicate_bridge-of\"\n]"
            },
            "auth": null
          },
          "protocolProfileBehavior": {
            "followRedirects": false,
            "followOriginalHttpMethod": false,
            "followAuthorizationHeader": false
          },
          "response": []
        }
      ],
      "protocolProfileBehavior": null,
      "response": []
    },
    {
      "name": "LINK GRAPHS",
      "item": [
        {
          "name": "Get linked keys",
          "request": {
            "method": "POST",
            "url": {
              "raw": "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/link/keys?predicate=_predicate_requires_indicator",
              "query": [
                {
                  "key": "predicate",
                  "value": "_predicate_requires_indicator",
                  "disabled": false,
                  "description": "Link predicate, here are some examples:\n_predicate_requires_indicator: Requires indicator.\n_predicate_requires_metadata: Required metadata indicator."
                }
              ],
              "protocol": null,
              "host": [
                "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/link/keys"
              ],
              "port": null,
              "path": null
            },
            "description": "Use this service if you want to retrieve the flattened list of document keys linked to the provided list of global identifiers with the provided predicate.\n\n*In order to use this service, the current user must have the `read` role*.\n\nThe service expects the link predicate as a path query parameter, and the list of descriptor global identifiers in the request body. The service will return the list of all the elements linked to the provided list of keys with the provided predicate.\n\nYou can try providing `_predicate_requires_indicator` as the predicate, and `chr_EffPopSize` in the list of nodes to get the list of additional descriptors you should add to a dataset that features the `chr_EffPopSize` descriptor.\n\n*Note that the structure is recursive, so selected required descriptors might, in turn, require other descriptors*.\n\nIf the operation does not succeed, the service will return:\n\n- `401`: **No current user**: the service will return this code if no user is currently logged in.\n- `403`: **Unauthorised user**: the service will return this code if the current user is not an administrator.\n- `500`: For other types of error.",
            "header": [],
            "body": {
              "mode": "raw",
              "disabled": false,
              "raw": "[ \"chr_EffPopSize\" ]"
            },
            "auth": null
          },
          "protocolProfileBehavior": {
            "followRedirects": false,
            "followOriginalHttpMethod": false,
            "followAuthorizationHeader": false
          },
          "response": []
        },
        {
          "name": "Get linked terms",
          "request": {
            "method": "POST",
            "url": {
              "raw": "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/link/terms?predicate=_predicate_requires_indicator",
              "query": [
                {
                  "key": "predicate",
                  "value": "_predicate_requires_indicator",
                  "disabled": false,
                  "description": "Link predicate, here are some examples:\n_predicate_requires_indicator: Requires indicator.\n_predicate_requires_metadata: Required metadata indicator."
                }
              ],
              "protocol": null,
              "host": [
                "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/link/terms"
              ],
              "port": null,
              "path": null
            },
            "description": "Use this service if you want to retrieve the flattened list of terms linked to the provided list of global identifiers with the provided predicate.\n\n*In order to use this service, the current user must have the `read` role*.\n\nThe service expects the link predicate as a path query parameter, and the list of descriptor global identifiers in the request body. The service will return the list of all the term records linked to the provided list of keys with the provided predicate.\n\nYou can try providing `_predicate_requires_indicator` as the predicate, and `chr_EffPopSize` in the list of nodes to get the list of additional descriptors you should add to a dataset that features the `chr_EffPopSize` descriptor.\n\n*Note that the structure is recursive, so selected required descriptors might, in turn, require other descriptors*.\n\nIf the operation does not succeed, the service will return:\n\n- `401`: **No current user**: the service will return this code if no user is currently logged in.\n- `403`: **Unauthorised user**: the service will return this code if the current user is not an administrator.\n- `500`: For other types of error.",
            "header": [],
            "body": {
              "mode": "raw",
              "disabled": false,
              "raw": "[ \"chr_EffPopSize\" ]"
            },
            "auth": null
          },
          "protocolProfileBehavior": {
            "followRedirects": false,
            "followOriginalHttpMethod": false,
            "followAuthorizationHeader": false
          },
          "response": []
        }
      ],
      "protocolProfileBehavior": null,
      "response": []
    },
    {
      "name": "DESCRIPTOR TYPES",
      "item": [
        {
          "name": "Descriptor categories ",
          "request": {
            "method": "POST",
            "url": {
              "raw": "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/descr/qual/keys",
              "query": null,
              "protocol": null,
              "host": [
                "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/descr/qual/keys"
              ],
              "port": null,
              "path": null
            },
            "description": "Use this service to get the summary of qualifications for the provided list of descriptors.\n\n*In order to use this service, the current user must have the `read` role*.\n\nThe service expects a *list of descriptor global identifiers* in the *request body* and will return the list of *classes*, *domains*, *tags* and *subjects* associated with the *provided descriptors list*.\n\nIf the service is successful, [`200`], it will return the following structure:\n\n- `classes`: List of class, `_class`, entries featured by the provided list of descriptors.\n- `domains`: List of domain, `_domain`, entries featured by the provided list of descriptors.\n- `tags`: List of tag, `_tag`, entries featured by the provided list of descriptors.\n- `subjects`: List of subject, `_subject`, entries featured by the provided list of descriptors.\n\nIf the operation does not succeed, the service will return:\n\n- `401`: **No current user**: the service will return this code if no user is currently logged in.\n- `403`: **Unauthorised user**: the service will return this code if the current user is not an administrator.\n- `500`: For other types of error.",
            "header": [],
            "body": {
              "mode": "raw",
              "disabled": false,
              "raw": "[ \"chr_EffPopSize\" ]"
            },
            "auth": null
          },
          "protocolProfileBehavior": {
            "followRedirects": false,
            "followOriginalHttpMethod": false,
            "followAuthorizationHeader": false
          },
          "response": []
        },
        {
          "name": "Descriptor keys ",
          "request": {
            "method": "POST",
            "url": {
              "raw": "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/descr/query/keys?op=AND",
              "query": [
                {
                  "key": "op",
                  "value": "AND",
                  "disabled": false,
                  "description": "Chaining operator for query filters."
                }
              ],
              "protocol": null,
              "host": [
                "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/descr/query/keys"
              ],
              "port": null,
              "path": null
            },
            "description": "Use this service to query descriptors and retrieve the list of matching global identifiers.\n\n*In order to use this service, the current user must have the `read` role*.\n\nThe service expects the selection criteria in the request body:\n\n- `start`: *Start position* in results, provide an integer greater or equal to 0. *This property is required*, if omitted it will defult to `0`.\n- `limit`: *Number of elements* to be returned, provide an integer. *This property is required*, if omitted it will defult to `25`.\n- `_subject`: Provide the list of *subject* enumerations to match.\n- `_class`: Provide the list of *class* enumerations to match.\n- `_domain`: Provide the list of *domain* enumerations to match.\n- `_list`: Provide the selection of *list* enumerations to match.\n- `_tag`: Provide the list of *tag* enumerations to match.\n\nThe first two parameters are required, if you want to ignore any of the other ones, remove the property.\n\nA query parameter, `op`, is used to join the query filters. It can have the value of `AND` or `OR`.\n\nIf the service is successful, [`200`], it will return the list of matching descriptor global identifiers.\n\nIf the operation does not succeed, the service will return:\n\n- `401`: **No current user**: the service will return this code if no user is currently logged in.\n- `403`: **Unauthorised user**: the service will return this code if the current user is not an administrator.\n- `500`: For other types of error.",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json",
                "disabled": false,
                "description": null
              }
            ],
            "body": {
              "mode": "raw",
              "disabled": false,
              "raw": "{\"start\":0,\"limit\":25,\"_subject\":[\"chr_subject_target\"],\"_class\":[\"_class_quantity\"],\"_domain\":[\"chr_fore\"],\"_tag\":[\"chr_tag_diversity\"]}"
            },
            "auth": null
          },
          "protocolProfileBehavior": {
            "followRedirects": false,
            "followOriginalHttpMethod": false,
            "followAuthorizationHeader": false
          },
          "response": []
        },
        {
          "name": "Descriptor terms ",
          "request": {
            "method": "POST",
            "url": {
              "raw": "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/descr/query/terms?op=AND",
              "query": [
                {
                  "key": "op",
                  "value": "AND",
                  "disabled": false,
                  "description": "Chaining operator for query filters."
                }
              ],
              "protocol": null,
              "host": [
                "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/descr/query/terms"
              ],
              "port": null,
              "path": null
            },
            "description": "Use this service to query descriptors and retrieve the list of matching term records.\n\n*In order to use this service, the current user must have the `read` role*.\n\nThe service expects the selection criteria in the request body:\n\n- `start`: *Start position* in results, provide an integer greater or equal to 0. *This property is required*, if omitted it will defult to `0`.\n- `limit`: *Number of elements* to be returned, provide an integer. *This property is required*, if omitted it will defult to `25`.\n- `_subject`: Provide the list of *subject* enumerations to match.\n- `_class`: Provide the list of *class* enumerations to match.\n- `_domain`: Provide the list of *domain* enumerations to match.\n- `_list`: Provide the selection of *list* enumerations to match.\n- `_tag`: Provide the list of *tag* enumerations to match.\n\nThe first two parameters are required, if you want to ignore any of the other ones, remove the property.\n\nA query parameter, `op`, is used to join the query filters. It can have the value of `AND` or `OR`.\n\nIf the service is successful, [`200`], it will return the list of matching descriptor term records.\n\nIf the operation does not succeed, the service will return:\n\n- `401`: **No current user**: the service will return this code if no user is currently logged in.\n- `403`: **Unauthorised user**: the service will return this code if the current user is not an administrator.\n- `500`: For other types of error.",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json",
                "disabled": false,
                "description": null
              }
            ],
            "body": {
              "mode": "raw",
              "disabled": false,
              "raw": "{\"start\":0,\"limit\":25,\"_subject\":[\"chr_subject_target\"],\"_class\":[\"_class_quantity\"],\"_domain\":[\"chr_fore\"],\"_tag\":[\"chr_tag_diversity\"]}"
            },
            "auth": null
          },
          "protocolProfileBehavior": {
            "followRedirects": false,
            "followOriginalHttpMethod": false,
            "followAuthorizationHeader": false
          },
          "response": []
        }
      ],
      "protocolProfileBehavior": null,
      "response": []
    },
    {
      "name": "VALIDATION",
      "item": [
        {
          "name": "Validate value by descriptor",
          "request": {
            "method": "POST",
            "url": {
              "raw": "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/check/descriptor/value?descriptor=_term&cache=true&miss=true&terms=true&types=false&defns=false&resolve=true&resfld=_aid",
              "query": [
                {
                  "key": "descriptor",
                  "value": "_term",
                  "disabled": false,
                  "description": "Descriptor.\nProvide the global identifier of the descriptor associated with the provided value."
                },
                {
                  "key": "cache",
                  "value": "true",
                  "disabled": false,
                  "description": "Use cache.\nCache all terms used in the validation procedure. This can speed the .execution when validating large lists of values."
                },
                {
                  "key": "miss",
                  "value": "true",
                  "disabled": false,
                  "description": "Cache unresolved references.\nThis option is only relevant if the use cache flag is set. If set, also unresolved term references will be cached, this can be useful if the data contains a large number of incorrect references with the same value."
                },
                {
                  "key": "terms",
                  "value": "true",
                  "disabled": false,
                  "description": "Expect all object properties to be part of the data dictionary.\nBy default, if a property matches a descriptor, then the value must conform to the descriptor's data definition; if the property does not match a term in the data dictionary, then it will be ignored and assumed correct. If you set this flag, all object properties must correspond to a descriptor, failing to do so will be considered an error."
                },
                {
                  "key": "types",
                  "value": "false",
                  "disabled": false,
                  "description": "Expect all descriptors to have a data type.\nBy default, an empty descriptor data definition section means that it can take any value: if you set this flag, all descriptors are required to have a data type."
                },
                {
                  "key": "defns",
                  "value": "false",
                  "disabled": false,
                  "description": "Allow referencing default namespace.\nThe default namespace is reserved to terms that constitute the dictionary engine. User-defined terms should not reference the default namespace. If this option is set, it will be possible to create terms that have the default namespace as their namespace."
                },
                {
                  "key": "resolve",
                  "value": "true",
                  "disabled": false,
                  "description": "Attempt to resolve unmatched term references.\nThis option is relevant to enumerated values. If this flag is set, when a provided value does not resolve into a term global identifier, the value will be tested against the terms code section property indicated in the resfld parameter: if there is a single match, the original value will be replaced by the matched global identifier. This way one can use the local identifier as the reference and let the validator resolve the global identifier.\nWhen this happens the status code will be zero, if no errors have occurred, but the response will feature a property named changes in the status report, which contains the list of resolved values.\nBe aware that to successfully use this feature the local identifiers must be unique."
                },
                {
                  "key": "resfld",
                  "value": "_aid",
                  "disabled": false,
                  "description": "Terms code section field used to resolve term references.\nThis option is relevant if the resolve flag was set. This parameter corresponds to the name of a property in the descriptor's code section: the unresolved value will be matched against the value contained in that field and if there is a single match, the matched term global identifier will replace the provided value.\nBy default this parameter is set to the local identifier, you could set it, for instance, to the list of official identifiers in order to have a larger choice."
                }
              ],
              "protocol": null,
              "host": [
                "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/check/descriptor/value"
              ],
              "port": null,
              "path": null
            },
            "description": "Use this service to check a data value matched to a descriptor.\n\n*In order to use this service, the current user must have the `read` role*.\n\nThis service can be used to *check* if a *data value* matches the *rules* of a *descriptor*. The value will be validated against the data definition associated with the descriptor and the service will return an object describing the status of the validation and eventual additional information describing the outcome.\n\nThe service expects the *descriptor global identifier* among the path query parameters and the *value* in the request body.\nThe service also expects a series of path query parameters that can be used to customise the conditions condidered in the validation.\n\nIf the service is successful, [`200`], it will return an object with a single property, `status`, whose value will be *zero*.\n\nIf the `resolve` parameter was set and the validation encountered no errors, bu at least one value got resolved, the service will return the [`202`] status and an object structured as follows:\n\n- `status`: The validation status which will be the number *one*.\n- `report`: The validation report:\n    - `status`: The status report:\n      - `code`: The status code, that will be zero.\n      - `message`: The status report message.\n    - `changes`: The list of resolved values:\n      - *hash*: This will be a hash used to disambiguate and group resolved values.\n      - `field`: The property name.\n      - `original`: The original value.\n      - `resolved`: The resolved value.\n- `value`: The provided value with modifications applied.\n\nIf the value did not pass the validation, the service will return a [`400`] status and an object structured as follows:\n\n- `status`: The validation status which will be the number *minus one*.\n- `report`: The validation report:\n    - `status`: The status report:\n      - `code`: The status code, that will be *non-zero*.\n      - `message`: The status report message.\n    - `descriptor`: The name of the property that triggered the error.\n    - `value`: the value that triggered the error.\n- `value`: The provided value with modifications applied.\n\n\nIf the operation does not succeed, the service may also return:\n\n- `401`: **No current user**: the service will return this code if no user is currently logged in.\n- `403`: **Unauthorised user**: the service will return this code if the current user is not an administrator.\n- `500`: For other types of error.",
            "header": [],
            "body": {
              "mode": "raw",
              "disabled": false,
              "raw": "{\n    \"_key\": \"TEST-03\",\n    \"_code\": {\n        \"_lid\": \"TEST-03\",\n        \"_gid\": \"TEST-03\",\n        \"_aid\": [ \"TEST-03\" ],\n        \"_name\": \"My test object descriptor\"\n    },\n    \"_info\": {\n        \"_title\": {\"en\": \"Test descriptor.\"}\n    },\n    \"_data\": {\n        \"_scalar\": {\n            \"_type\": \"object\",\n            \"_kind\": [\"TEST-03\"]\n        }\n    }\n}"
            },
            "auth": null
          },
          "protocolProfileBehavior": {
            "followRedirects": false,
            "followOriginalHttpMethod": false,
            "followAuthorizationHeader": false
          },
          "response": []
        },
        {
          "name": "Validate values by descriptor",
          "request": {
            "method": "POST",
            "url": {
              "raw": "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/check/descriptor/values?descriptor=_type&cache=true&miss=true&terms=true&types=false&defns=false&resolve=true&resfld=_aid",
              "query": [
                {
                  "key": "descriptor",
                  "value": "_type",
                  "disabled": false,
                  "description": "Descriptor.\nProvide the global identifier of the descriptor associated with the provided value."
                },
                {
                  "key": "cache",
                  "value": "true",
                  "disabled": false,
                  "description": "Use cache.\nCache all terms used in the validation procedure. This can speed the .execution when validating large lists of values."
                },
                {
                  "key": "miss",
                  "value": "true",
                  "disabled": false,
                  "description": "Cache unresolved references.\nThis option is only relevant if the use cache flag is set. If set, also unresolved term references will be cached, this can be useful if the data contains a large number of incorrect references with the same value."
                },
                {
                  "key": "terms",
                  "value": "true",
                  "disabled": false,
                  "description": "Expect all object properties to be part of the data dictionary.\nBy default, if a property matches a descriptor, then the value must conform to the descriptor's data definition; if the property does not match a term in the data dictionary, then it will be ignored and assumed correct. If you set this flag, all object properties must correspond to a descriptor, failing to do so will be considered an error."
                },
                {
                  "key": "types",
                  "value": "false",
                  "disabled": false,
                  "description": "Expect all descriptors to have a data type.\nBy default, an empty descriptor data definition section means that it can take any value: if you set this flag, all descriptors are required to have a data type."
                },
                {
                  "key": "defns",
                  "value": "false",
                  "disabled": false,
                  "description": "Allow referencing default namespace.\nThe default namespace is reserved to terms that constitute the dictionary engine. User-defined terms should not reference the default namespace. If this option is set, it will be possible to create terms that have the default namespace as their namespace."
                },
                {
                  "key": "resolve",
                  "value": "true",
                  "disabled": false,
                  "description": "Attempt to resolve unmatched term references.\nThis option is relevant to enumerated values. If this flag is set, when a provided value does not resolve into a term global identifier, the value will be tested against the terms code section property indicated in the resfld parameter: if there is a single match, the original value will be replaced by the matched global identifier. This way one can use the local identifier as the reference and let the validator resolve the global identifier.\nWhen this happens the status code will be zero, if no errors have occurred, but the response will feature a property named changes in the status report, which contains the list of resolved values.\nBe aware that to successfully use this feature the local identifiers must be unique."
                },
                {
                  "key": "resfld",
                  "value": "_aid",
                  "disabled": false,
                  "description": "Terms code section field used to resolve term references.\nThis option is relevant if the resolve flag was set. This parameter corresponds to the name of a property in the descriptor's code section: the unresolved value will be matched against the value contained in that field and if there is a single match, the matched term global identifier will replace the provided value.\nBy default this parameter is set to the local identifier, you could set it, for instance, to the list of official identifiers in order to have a larger choice."
                }
              ],
              "protocol": null,
              "host": [
                "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/check/descriptor/values"
              ],
              "port": null,
              "path": null
            },
            "description": "Use this service to check a data value matched to a descriptor.\n\n*In order to use this service, the current user must have the `read` role*.\n\nThis service can be used to *check* if a list of *data values* matches the *rules* of a *descriptor*. Each value will be validated against the data definition associated with the descriptor and the service will return an object describing the status of the validation and eventual additional information describing the outcome.\n\nThe service expects the *descriptor global identifier* among the path query parameters and the list of *values* in the request body.\nThe service also expects a series of path query parameters that can be used to customise the conditions condidered in the validation.\n\nIf the service is successful, [`200`], it will return an object with the following properties:\n\n- `status`: The status of the operation, will be *zero*.\n- `descriptor`: The descriptor global identifier.\n- `valid`: Number of valid items.\n- `warnings`: Number of items with resolved values, will be *zero*.\n- `errors`: Number of incorrect items, will be *zero*.\n\nIf the `resolve` parameter was set and the validation encountered no errors, bu at least one value got resolved, the service will return the [`202`] status and an object structured as follows:\n\n- `status`: The validation status which will be the number *one*.\n- `descriptor`: The descriptor provided to the service.\n- `valid`: Number of valid items.\n- `warnings`: Number of items with resolved values.\n- `errors`: Number of invalid items, will be *none*.\n- `reports`: The list of validation reports, one for each item with resolved values:\n  - `status`: The status of the current report, will be *one*.\n  - `report`: The status report:\n    - `status`: The status report:\n      - `code`: The status code, that will be *zero*.\n      - `message`: The status report message.\n    - `changes`: The list of resolved values:\n      - *hash*: This will be a hash used to disambiguate and group resolved values.\n      - `field`: The property name.\n      - `original`: The original value.\n      - `resolved`: The resolved value.\n- `values`: The list of provided items that has resolved values.\n\nIf any of the items did not pass the validation, the service will return a [`400`] status and an object structured as follows:\n\n- `status`: The validation status which will be the number *minus one*.\n- `descriptor`: The descriptor provided to the service.\n- `valid`: Number of valid items.\n- `warnings`: Number of items with resolved values.\n- `errors`: Number of invalid items.\n- `reports`: The list of validation reports, one for each item with resolved values:\n  - `status`: The status of the current report, will be *one* or *minus one*.\n  - `report`: The status report:\n    - `status`: The status report:\n      - `code`: The status code.\n      - `message`: The status report message.\n    - `descriptor`: The descriptor that triggered the error.\n    - `value`: The incorrect value.\n- `values`: The list of provided items that has resolved values or that were incorrect.\n\nIf the operation does not succeed, the service may also return:\n\n- `401`: **No current user**: the service will return this code if no user is currently logged in.\n- `403`: **Unauthorised user**: the service will return this code if the current user is not an administrator.\n- `500`: For other types of error.",
            "header": [],
            "body": {
              "mode": "raw",
              "disabled": false,
              "raw": "[\n  \"_type_string_enum\",\n  12,\n  \"object\"\n]"
            },
            "auth": null
          },
          "protocolProfileBehavior": {
            "followRedirects": false,
            "followOriginalHttpMethod": false,
            "followAuthorizationHeader": false
          },
          "response": []
        },
        {
          "name": "Validate object",
          "request": {
            "method": "POST",
            "url": {
              "raw": "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/check/object?cache=true&miss=true&terms=false&types=false&defns=false&resolve=true&resfld=_aid",
              "query": [
                {
                  "key": "cache",
                  "value": "true",
                  "disabled": false,
                  "description": "Use cache.\nCache all terms used in the validation procedure. This can speed the .execution when validating large lists of values."
                },
                {
                  "key": "miss",
                  "value": "true",
                  "disabled": false,
                  "description": "Cache unresolved references.\nThis option is only relevant if the use cache flag is set. If set, also unresolved term references will be cached, this can be useful if the data contains a large number of incorrect references with the same value."
                },
                {
                  "key": "terms",
                  "value": "false",
                  "disabled": false,
                  "description": "Expect all object properties to be part of the data dictionary.\nBy default, if a property matches a descriptor, then the value must conform to the descriptor's data definition; if the property does not match a term in the data dictionary, then it will be ignored and assumed correct. If you set this flag, all object properties must correspond to a descriptor, failing to do so will be considered an error."
                },
                {
                  "key": "types",
                  "value": "false",
                  "disabled": false,
                  "description": "Expect all descriptors to have a data type.\nBy default, an empty descriptor data definition section means that it can take any value: if you set this flag, all descriptors are required to have a data type."
                },
                {
                  "key": "defns",
                  "value": "false",
                  "disabled": false,
                  "description": "Allow referencing default namespace.\nThe default namespace is reserved to terms that constitute the dictionary engine. User-defined terms should not reference the default namespace. If this option is set, it will be possible to create terms that have the default namespace as their namespace."
                },
                {
                  "key": "resolve",
                  "value": "true",
                  "disabled": false,
                  "description": "Attempt to resolve unmatched term references.\nThis option is relevant to enumerated values. If this flag is set, when a provided value does not resolve into a term global identifier, the value will be tested against the terms code section property indicated in the resfld parameter: if there is a single match, the original value will be replaced by the matched global identifier. This way one can use the local identifier as the reference and let the validator resolve the global identifier.\nWhen this happens the status code will be zero, if no errors have occurred, but the response will feature a property named changes in the status report, which contains the list of resolved values.\nBe aware that to successfully use this feature the local identifiers must be unique."
                },
                {
                  "key": "resfld",
                  "value": "_aid",
                  "disabled": false,
                  "description": "Terms code section field used to resolve term references.\nThis option is relevant if the resolve flag was set. This parameter corresponds to the name of a property in the descriptor's code section: the unresolved value will be matched against the value contained in that field and if there is a single match, the matched term global identifier will replace the provided value.\nBy default this parameter is set to the local identifier, you could set it, for instance, to the list of official identifiers in order to have a larger choice."
                }
              ],
              "protocol": null,
              "host": [
                "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/check/object"
              ],
              "port": null,
              "path": null
            },
            "description": "Use this service to check the provided object.\n\n*In order to use this service, the current user must have the `read` role*.\n\nThis service can be used to *check* the *properties* of the provided *object*. It will *scan all properties* and *validate* any property that *corresponds* to a *descriptor* of the *data dictionary*.\n\nThe service expects the objects in the request body and it also expects a series of path query parameters that can be used to customise the conditions condidered in the validation.\n\nIf the service is successful, [`200`], it will return an object with a single property, `status`, whose value will be *zero*.\n\nIf the `resolve` parameter was set and the validation encountered no errors, bu at least one value got resolved, the service will return the [`202`] status and an object structured as follows:\n\n- `status`: The validation status which will be the number *one*.\n- `report`: The validation report:\n    - `status`: The status report:\n      - `code`: The status code, that will be zero.\n      - `message`: The status report message.\n    - `changes`: The list of resolved values:\n      - *hash*: This will be a hash used to disambiguate and group resolved values.\n      - `field`: The property name.\n      - `original`: The original value.\n      - `resolved`: The resolved value.\n- `value`: The provided value with modifications applied.\n\nIf the value did not pass the validation, the service will return a [`400`] status and an object structured as follows:\n\n- `status`: The validation status which will be the number *minus one*.\n- `report`: The validation report:\n    - `status`: The status report:\n      - `code`: The status code, that will be *non-zero*.\n      - `message`: The status report message.\n    - `descriptor`: The name of the property that triggered the error.\n    - `value`: the value that triggered the error.\n- `value`: The provided value with modifications applied.\n\n\nIf the operation does not succeed, the service may also return:\n\n- `401`: **No current user**: the service will return this code if no user is currently logged in.\n- `403`: **Unauthorised user**: the service will return this code if the current user is not an administrator.\n- `500`: For other types of error.",
            "header": [],
            "body": {
              "mode": "raw",
              "disabled": false,
              "raw": "{\n  \"_info\": {\n    \"_title\": {\n      \"en\": \"Test term 1\"\n    }\n  },\n  \"_data\": {\n    \"_scalar\": {\n      \"_type\": \"object\"\n    }\n  },\n  \"language\": \"eng\",\n  \"custom_value\": 42\n}"
            },
            "auth": null
          },
          "protocolProfileBehavior": {
            "followRedirects": false,
            "followOriginalHttpMethod": false,
            "followAuthorizationHeader": false
          },
          "response": []
        },
        {
          "name": "Validate objects",
          "request": {
            "method": "POST",
            "url": {
              "raw": "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/check/objects",
              "query": null,
              "protocol": null,
              "host": [
                "{{Protocol}}://{{Host}}:{{Port}}/_db/{{Db}}/{{Path}}/check/objects"
              ],
              "port": null,
              "path": null
            },
            "description": "Use this service to check a list provided objects.\n\n*In order to use this service, the current user must have the `read` role*.\n\nThis service can be used to *check* the *properties* of the provided list of *objects*. It will *scan all properties* and *validate* any property that *corresponds* to an *element of the data dictionary*.\n\nThe service expects the list of objects in the request body and a set of path query parameters that provide options to the validation process.\n\nIf the service is successful, [`200`], it will return an object with the following properties:\n\n- `status`: The status of the operation, will be *zero*.\n- `descriptor`: The descriptor global identifier.\n- `valid`: Number of valid items.\n- `warnings`: Number of items with resolved values, will be *zero*.\n- `errors`: Number of incorrect items, will be *zero*.\n\nIf the `resolve` parameter was set and the validation encountered no errors, bu at least one value got resolved, the service will return the [`202`] status and an object structured as follows:\n\n- `status`: The validation status which will be the number *one*.\n- `valid`: Number of valid items.\n- `warnings`: Number of items with resolved values.\n- `errors`: Number of invalid items, will be *none*.\n- `reports`: The list of validation reports, one for each item with resolved values:\n  - `status`: The status of the current report, will be *one*.\n  - `report`: The status report:\n    - `status`: The status report:\n      - `code`: The status code, that will be *zero*.\n      - `message`: The status report message.\n    - `changes`: The list of resolved values:\n      - *hash*: This will be a hash used to disambiguate and group resolved values.\n      - `field`: The property name.\n      - `original`: The original value.\n      - `resolved`: The resolved value.\n- `values`: The list of provided items that has resolved values.\n\nIf any of the items did not pass the validation, the service will return a [`400`] status and an object structured as follows:\n\n- `status`: The validation status which will be the number *minus one*.\n- `valid`: Number of valid items.\n- `warnings`: Number of items with resolved values.\n- `errors`: Number of invalid items.\n- `reports`: The list of validation reports, one for each item with resolved values:\n  - `status`: The status of the current report, will be *one* or *minus one*.\n  - `report`: The status report:\n    - `status`: The status report:\n      - `code`: The status code.\n      - `message`: The status report message.\n    - `descriptor`: The descriptor that triggered the error.\n    - `value`: The incorrect value.\n- `values`: The list of provided items that has resolved values or that were incorrect.\n\nIf the operation does not succeed, the service may also return:\n\n- `401`: **No current user**: the service will return this code if no user is currently logged in.\n- `403`: **Unauthorised user**: the service will return this code if the current user is not an administrator.\n- `500`: For other types of error.",
            "header": [],
            "body": {
              "mode": "raw",
              "disabled": false,
              "raw": "[\n    {\n        \"_info\": {\n            \"_title\": {\"iso_639_3_eng\": \"Test term 1\"}\n        },\n        \"_data\": {\n            \"_scalar\": {\"_type\": \"_type_object\"}\n        },\n        \"language\": \"eng\",\n        \"custom_value\": 42\n    },\n    {\n        \"_info\": {\n            \"_title\": {\"iso_639_3_eng\": \"Test term 2\"}\n        },\n        \"_data\": {\n            \"_scalar\": {\"_type\": \"_type_string\"}\n        }\n    }\n]"
            },
            "auth": null
          },
          "protocolProfileBehavior": {
            "followRedirects": false,
            "followOriginalHttpMethod": false,
            "followAuthorizationHeader": false
          },
          "response": []
        }
      ],
      "protocolProfileBehavior": null,
      "response": []
    }
  ]
}